// Generated by generate_from_gir.py
// DO NOT EDIT THIS FILE DIRECTLY

#include <flatpak/flatpak.h>
#include <glib.h>
#include <memory>
#include <napi.h>
#include <string>
#include <vector>

Napi::Value Wrap_BundleRef_new(const Napi::CallbackInfo& info);
Napi::Value Wrap_BundleRef_get_appstream(const Napi::CallbackInfo& info);
Napi::Value Wrap_BundleRef_get_file(const Napi::CallbackInfo& info);
Napi::Value Wrap_BundleRef_get_icon(const Napi::CallbackInfo& info);
Napi::Value Wrap_BundleRef_get_installed_size(const Napi::CallbackInfo& info);
Napi::Value Wrap_BundleRef_get_metadata(const Napi::CallbackInfo& info);
Napi::Value Wrap_BundleRef_get_origin(const Napi::CallbackInfo& info);
Napi::Value Wrap_BundleRef_get_runtime_repo_url(const Napi::CallbackInfo& info);
Napi::Value Wrap_Installation_new_for_path(const Napi::CallbackInfo& info);
Napi::Value Wrap_Installation_new_system(const Napi::CallbackInfo& info);
Napi::Value Wrap_Installation_new_system_with_id(const Napi::CallbackInfo& info);
Napi::Value Wrap_Installation_new_user(const Napi::CallbackInfo& info);
Napi::Value Wrap_Installation_add_remote(const Napi::CallbackInfo& info);
Napi::Value Wrap_Installation_cleanup_local_refs_sync(const Napi::CallbackInfo& info);
Napi::Value Wrap_Installation_create_monitor(const Napi::CallbackInfo& info);
Napi::Value Wrap_Installation_drop_caches(const Napi::CallbackInfo& info);
Napi::Value Wrap_Installation_fetch_remote_metadata_sync(const Napi::CallbackInfo& info);
Napi::Value Wrap_Installation_fetch_remote_ref_sync(const Napi::CallbackInfo& info);
Napi::Value Wrap_Installation_fetch_remote_ref_sync_full(const Napi::CallbackInfo& info);
Napi::Value Wrap_Installation_fetch_remote_size_sync(const Napi::CallbackInfo& info);
Napi::Value Wrap_Installation_get_config(const Napi::CallbackInfo& info);
Napi::Value Wrap_Installation_get_current_installed_app(const Napi::CallbackInfo& info);
Napi::Value Wrap_Installation_get_default_languages(const Napi::CallbackInfo& info);
Napi::Value Wrap_Installation_get_default_locales(const Napi::CallbackInfo& info);
Napi::Value Wrap_Installation_get_display_name(const Napi::CallbackInfo& info);
Napi::Value Wrap_Installation_get_id(const Napi::CallbackInfo& info);
Napi::Value Wrap_Installation_get_installed_ref(const Napi::CallbackInfo& info);
Napi::Value Wrap_Installation_get_is_user(const Napi::CallbackInfo& info);
Napi::Value Wrap_Installation_get_min_free_space_bytes(const Napi::CallbackInfo& info);
Napi::Value Wrap_Installation_get_no_interaction(const Napi::CallbackInfo& info);
Napi::Value Wrap_Installation_get_path(const Napi::CallbackInfo& info);
Napi::Value Wrap_Installation_get_priority(const Napi::CallbackInfo& info);
Napi::Value Wrap_Installation_get_remote_by_name(const Napi::CallbackInfo& info);
Napi::Value Wrap_Installation_get_storage_type(const Napi::CallbackInfo& info);
Napi::Value Wrap_Installation_install_ref_file(const Napi::CallbackInfo& info);
Napi::Value Wrap_Installation_launch(const Napi::CallbackInfo& info);
Napi::Value Wrap_Installation_launch_full(const Napi::CallbackInfo& info);
Napi::Value Wrap_Installation_list_installed_refs(const Napi::CallbackInfo& info);
Napi::Value Wrap_Installation_list_installed_refs_by_kind(const Napi::CallbackInfo& info);
Napi::Value Wrap_Installation_list_installed_refs_for_update(const Napi::CallbackInfo& info);
Napi::Value Wrap_Installation_list_installed_related_refs_sync(const Napi::CallbackInfo& info);
Napi::Value Wrap_Installation_list_pinned_refs(const Napi::CallbackInfo& info);
Napi::Value Wrap_Installation_list_remote_refs_sync(const Napi::CallbackInfo& info);
Napi::Value Wrap_Installation_list_remote_refs_sync_full(const Napi::CallbackInfo& info);
Napi::Value Wrap_Installation_list_remote_related_refs_for_installed_sync(const Napi::CallbackInfo& info);
Napi::Value Wrap_Installation_list_remote_related_refs_sync(const Napi::CallbackInfo& info);
Napi::Value Wrap_Installation_list_remotes(const Napi::CallbackInfo& info);
Napi::Value Wrap_Installation_list_unused_refs(const Napi::CallbackInfo& info);
Napi::Value Wrap_Installation_list_unused_refs_with_options(const Napi::CallbackInfo& info);
Napi::Value Wrap_Installation_load_app_overrides(const Napi::CallbackInfo& info);
Napi::Value Wrap_Installation_modify_remote(const Napi::CallbackInfo& info);
Napi::Value Wrap_Installation_prune_local_repo(const Napi::CallbackInfo& info);
Napi::Value Wrap_Installation_remove_local_ref_sync(const Napi::CallbackInfo& info);
Napi::Value Wrap_Installation_remove_remote(const Napi::CallbackInfo& info);
Napi::Value Wrap_Installation_run_triggers(const Napi::CallbackInfo& info);
Napi::Value Wrap_Installation_set_config_sync(const Napi::CallbackInfo& info);
Napi::Value Wrap_Installation_set_no_interaction(const Napi::CallbackInfo& info);
Napi::Value Wrap_Installation_update_appstream_sync(const Napi::CallbackInfo& info);
Napi::Value Wrap_Installation_update_remote_sync(const Napi::CallbackInfo& info);
Napi::Value Wrap_InstalledRef_get_appdata_content_rating(const Napi::CallbackInfo& info);
Napi::Value Wrap_InstalledRef_get_appdata_content_rating_type(const Napi::CallbackInfo& info);
Napi::Value Wrap_InstalledRef_get_appdata_license(const Napi::CallbackInfo& info);
Napi::Value Wrap_InstalledRef_get_appdata_name(const Napi::CallbackInfo& info);
Napi::Value Wrap_InstalledRef_get_appdata_summary(const Napi::CallbackInfo& info);
Napi::Value Wrap_InstalledRef_get_appdata_version(const Napi::CallbackInfo& info);
Napi::Value Wrap_InstalledRef_get_deploy_dir(const Napi::CallbackInfo& info);
Napi::Value Wrap_InstalledRef_get_eol(const Napi::CallbackInfo& info);
Napi::Value Wrap_InstalledRef_get_eol_rebase(const Napi::CallbackInfo& info);
Napi::Value Wrap_InstalledRef_get_installed_size(const Napi::CallbackInfo& info);
Napi::Value Wrap_InstalledRef_get_is_current(const Napi::CallbackInfo& info);
Napi::Value Wrap_InstalledRef_get_latest_commit(const Napi::CallbackInfo& info);
Napi::Value Wrap_InstalledRef_get_origin(const Napi::CallbackInfo& info);
Napi::Value Wrap_InstalledRef_get_subpaths(const Napi::CallbackInfo& info);
Napi::Value Wrap_InstalledRef_load_appdata(const Napi::CallbackInfo& info);
Napi::Value Wrap_InstalledRef_load_metadata(const Napi::CallbackInfo& info);
Napi::Value Wrap_Instance_get_app(const Napi::CallbackInfo& info);
Napi::Value Wrap_Instance_get_arch(const Napi::CallbackInfo& info);
Napi::Value Wrap_Instance_get_branch(const Napi::CallbackInfo& info);
Napi::Value Wrap_Instance_get_child_pid(const Napi::CallbackInfo& info);
Napi::Value Wrap_Instance_get_commit(const Napi::CallbackInfo& info);
Napi::Value Wrap_Instance_get_id(const Napi::CallbackInfo& info);
Napi::Value Wrap_Instance_get_info(const Napi::CallbackInfo& info);
Napi::Value Wrap_Instance_get_pid(const Napi::CallbackInfo& info);
Napi::Value Wrap_Instance_get_runtime(const Napi::CallbackInfo& info);
Napi::Value Wrap_Instance_get_runtime_commit(const Napi::CallbackInfo& info);
Napi::Value Wrap_Instance_is_running(const Napi::CallbackInfo& info);
Napi::Value Wrap_Ref_format_ref(const Napi::CallbackInfo& info);
Napi::Value Wrap_Ref_format_ref_cached(const Napi::CallbackInfo& info);
Napi::Value Wrap_Ref_get_arch(const Napi::CallbackInfo& info);
Napi::Value Wrap_Ref_get_branch(const Napi::CallbackInfo& info);
Napi::Value Wrap_Ref_get_collection_id(const Napi::CallbackInfo& info);
Napi::Value Wrap_Ref_get_commit(const Napi::CallbackInfo& info);
Napi::Value Wrap_Ref_get_kind(const Napi::CallbackInfo& info);
Napi::Value Wrap_Ref_get_name(const Napi::CallbackInfo& info);
Napi::Value Wrap_RelatedRef_get_subpaths(const Napi::CallbackInfo& info);
Napi::Value Wrap_RelatedRef_should_autoprune(const Napi::CallbackInfo& info);
Napi::Value Wrap_RelatedRef_should_delete(const Napi::CallbackInfo& info);
Napi::Value Wrap_RelatedRef_should_download(const Napi::CallbackInfo& info);
Napi::Value Wrap_Remote_new(const Napi::CallbackInfo& info);
Napi::Value Wrap_Remote_new_from_file(const Napi::CallbackInfo& info);
Napi::Value Wrap_Remote_get_appstream_dir(const Napi::CallbackInfo& info);
Napi::Value Wrap_Remote_get_appstream_timestamp(const Napi::CallbackInfo& info);
Napi::Value Wrap_Remote_get_collection_id(const Napi::CallbackInfo& info);
Napi::Value Wrap_Remote_get_comment(const Napi::CallbackInfo& info);
Napi::Value Wrap_Remote_get_default_branch(const Napi::CallbackInfo& info);
Napi::Value Wrap_Remote_get_description(const Napi::CallbackInfo& info);
Napi::Value Wrap_Remote_get_disabled(const Napi::CallbackInfo& info);
Napi::Value Wrap_Remote_get_filter(const Napi::CallbackInfo& info);
Napi::Value Wrap_Remote_get_gpg_verify(const Napi::CallbackInfo& info);
Napi::Value Wrap_Remote_get_homepage(const Napi::CallbackInfo& info);
Napi::Value Wrap_Remote_get_icon(const Napi::CallbackInfo& info);
Napi::Value Wrap_Remote_get_main_ref(const Napi::CallbackInfo& info);
Napi::Value Wrap_Remote_get_name(const Napi::CallbackInfo& info);
Napi::Value Wrap_Remote_get_nodeps(const Napi::CallbackInfo& info);
Napi::Value Wrap_Remote_get_noenumerate(const Napi::CallbackInfo& info);
Napi::Value Wrap_Remote_get_prio(const Napi::CallbackInfo& info);
Napi::Value Wrap_Remote_get_remote_type(const Napi::CallbackInfo& info);
Napi::Value Wrap_Remote_get_title(const Napi::CallbackInfo& info);
Napi::Value Wrap_Remote_get_url(const Napi::CallbackInfo& info);
Napi::Value Wrap_Remote_set_collection_id(const Napi::CallbackInfo& info);
Napi::Value Wrap_Remote_set_comment(const Napi::CallbackInfo& info);
Napi::Value Wrap_Remote_set_default_branch(const Napi::CallbackInfo& info);
Napi::Value Wrap_Remote_set_description(const Napi::CallbackInfo& info);
Napi::Value Wrap_Remote_set_disabled(const Napi::CallbackInfo& info);
Napi::Value Wrap_Remote_set_filter(const Napi::CallbackInfo& info);
Napi::Value Wrap_Remote_set_gpg_key(const Napi::CallbackInfo& info);
Napi::Value Wrap_Remote_set_gpg_verify(const Napi::CallbackInfo& info);
Napi::Value Wrap_Remote_set_homepage(const Napi::CallbackInfo& info);
Napi::Value Wrap_Remote_set_icon(const Napi::CallbackInfo& info);
Napi::Value Wrap_Remote_set_main_ref(const Napi::CallbackInfo& info);
Napi::Value Wrap_Remote_set_nodeps(const Napi::CallbackInfo& info);
Napi::Value Wrap_Remote_set_noenumerate(const Napi::CallbackInfo& info);
Napi::Value Wrap_Remote_set_prio(const Napi::CallbackInfo& info);
Napi::Value Wrap_Remote_set_title(const Napi::CallbackInfo& info);
Napi::Value Wrap_Remote_set_url(const Napi::CallbackInfo& info);
Napi::Value Wrap_RemoteRef_get_download_size(const Napi::CallbackInfo& info);
Napi::Value Wrap_RemoteRef_get_eol(const Napi::CallbackInfo& info);
Napi::Value Wrap_RemoteRef_get_eol_rebase(const Napi::CallbackInfo& info);
Napi::Value Wrap_RemoteRef_get_installed_size(const Napi::CallbackInfo& info);
Napi::Value Wrap_RemoteRef_get_metadata(const Napi::CallbackInfo& info);
Napi::Value Wrap_RemoteRef_get_remote_name(const Napi::CallbackInfo& info);
Napi::Value Wrap_Transaction_new_for_installation(const Napi::CallbackInfo& info);
Napi::Value Wrap_Transaction_abort_webflow(const Napi::CallbackInfo& info);
Napi::Value Wrap_Transaction_add_default_dependency_sources(const Napi::CallbackInfo& info);
Napi::Value Wrap_Transaction_add_dependency_source(const Napi::CallbackInfo& info);
Napi::Value Wrap_Transaction_add_install_bundle(const Napi::CallbackInfo& info);
Napi::Value Wrap_Transaction_add_install_flatpakref(const Napi::CallbackInfo& info);
Napi::Value Wrap_Transaction_add_sideload_repo(const Napi::CallbackInfo& info);
Napi::Value Wrap_Transaction_add_uninstall(const Napi::CallbackInfo& info);
Napi::Value Wrap_Transaction_complete_basic_auth(const Napi::CallbackInfo& info);
Napi::Value Wrap_Transaction_get_auto_install_debug(const Napi::CallbackInfo& info);
Napi::Value Wrap_Transaction_get_auto_install_sdk(const Napi::CallbackInfo& info);
Napi::Value Wrap_Transaction_get_current_operation(const Napi::CallbackInfo& info);
Napi::Value Wrap_Transaction_get_include_unused_uninstall_ops(const Napi::CallbackInfo& info);
Napi::Value Wrap_Transaction_get_installation(const Napi::CallbackInfo& info);
Napi::Value Wrap_Transaction_get_no_deploy(const Napi::CallbackInfo& info);
Napi::Value Wrap_Transaction_get_no_interaction(const Napi::CallbackInfo& info);
Napi::Value Wrap_Transaction_get_no_pull(const Napi::CallbackInfo& info);
Napi::Value Wrap_Transaction_get_operation_for_ref(const Napi::CallbackInfo& info);
Napi::Value Wrap_Transaction_get_operations(const Napi::CallbackInfo& info);
Napi::Value Wrap_Transaction_get_parent_window(const Napi::CallbackInfo& info);
Napi::Value Wrap_Transaction_is_empty(const Napi::CallbackInfo& info);
Napi::Value Wrap_Transaction_run(const Napi::CallbackInfo& info);
Napi::Value Wrap_Transaction_set_auto_install_debug(const Napi::CallbackInfo& info);
Napi::Value Wrap_Transaction_set_auto_install_sdk(const Napi::CallbackInfo& info);
Napi::Value Wrap_Transaction_set_default_arch(const Napi::CallbackInfo& info);
Napi::Value Wrap_Transaction_set_disable_auto_pin(const Napi::CallbackInfo& info);
Napi::Value Wrap_Transaction_set_disable_dependencies(const Napi::CallbackInfo& info);
Napi::Value Wrap_Transaction_set_disable_prune(const Napi::CallbackInfo& info);
Napi::Value Wrap_Transaction_set_disable_related(const Napi::CallbackInfo& info);
Napi::Value Wrap_Transaction_set_disable_static_deltas(const Napi::CallbackInfo& info);
Napi::Value Wrap_Transaction_set_force_uninstall(const Napi::CallbackInfo& info);
Napi::Value Wrap_Transaction_set_include_unused_uninstall_ops(const Napi::CallbackInfo& info);
Napi::Value Wrap_Transaction_set_no_deploy(const Napi::CallbackInfo& info);
Napi::Value Wrap_Transaction_set_no_interaction(const Napi::CallbackInfo& info);
Napi::Value Wrap_Transaction_set_no_pull(const Napi::CallbackInfo& info);
Napi::Value Wrap_Transaction_set_parent_window(const Napi::CallbackInfo& info);
Napi::Value Wrap_Transaction_set_reinstall(const Napi::CallbackInfo& info);
Napi::Value Wrap_TransactionOperation_get_bundle_path(const Napi::CallbackInfo& info);
Napi::Value Wrap_TransactionOperation_get_commit(const Napi::CallbackInfo& info);
Napi::Value Wrap_TransactionOperation_get_download_size(const Napi::CallbackInfo& info);
Napi::Value Wrap_TransactionOperation_get_installed_size(const Napi::CallbackInfo& info);
Napi::Value Wrap_TransactionOperation_get_is_skipped(const Napi::CallbackInfo& info);
Napi::Value Wrap_TransactionOperation_get_metadata(const Napi::CallbackInfo& info);
Napi::Value Wrap_TransactionOperation_get_old_metadata(const Napi::CallbackInfo& info);
Napi::Value Wrap_TransactionOperation_get_operation_type(const Napi::CallbackInfo& info);
Napi::Value Wrap_TransactionOperation_get_ref(const Napi::CallbackInfo& info);
Napi::Value Wrap_TransactionOperation_get_related_to_ops(const Napi::CallbackInfo& info);
Napi::Value Wrap_TransactionOperation_get_remote(const Napi::CallbackInfo& info);
Napi::Value Wrap_TransactionOperation_get_requires_authentication(const Napi::CallbackInfo& info);
Napi::Value Wrap_TransactionOperation_get_subpaths(const Napi::CallbackInfo& info);
Napi::Value Wrap_TransactionProgress_get_bytes_transferred(const Napi::CallbackInfo& info);
Napi::Value Wrap_TransactionProgress_get_is_estimating(const Napi::CallbackInfo& info);
Napi::Value Wrap_TransactionProgress_get_progress(const Napi::CallbackInfo& info);
Napi::Value Wrap_TransactionProgress_get_start_time(const Napi::CallbackInfo& info);
Napi::Value Wrap_TransactionProgress_get_status(const Napi::CallbackInfo& info);
Napi::Value Wrap_TransactionProgress_set_update_frequency(const Napi::CallbackInfo& info);
Napi::Value Wrap_flatpak_error_quark(const Napi::CallbackInfo& info);
Napi::Value Wrap_flatpak_instance_get_all(const Napi::CallbackInfo& info);
Napi::Value Wrap_flatpak_portal_error_quark(const Napi::CallbackInfo& info);
Napi::Value Wrap_flatpak_ref_parse(const Napi::CallbackInfo& info);
Napi::Value Wrap_flatpak_transaction_operation_type_to_string(const Napi::CallbackInfo& info);
Napi::Value Wrap_flatpak_get_default_arch(const Napi::CallbackInfo& info);
Napi::Value Wrap_flatpak_get_supported_arches(const Napi::CallbackInfo& info);
Napi::Value Wrap_flatpak_get_system_installations(const Napi::CallbackInfo& info);

Napi::Value Wrap_BundleRef_new(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() <= 0 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected external object for parameter 'file'").ThrowAsJavaScriptException();
    return env.Null();
  }
  GFile* file = info[0].As<Napi::External<GFile>>().Data();

  GError* error = NULL;
  FlatpakBundleRef* result = flatpak_bundle_ref_new(file, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  // Return GObject of type BundleRef
  if (!result) {
    return env.Null();
  }
  // Increment reference count for GObject
  if (G_IS_OBJECT(result)) {
    g_object_ref(result);
    // Create external with finalizer
    return Napi::External<void>::New(env, result,
      [](Napi::Env env, void* obj) {
        if (obj && G_IS_OBJECT(obj)) {
          g_object_unref(static_cast<GObject*>(obj));
        }
      });
  } else {
    // Not a GObject, just pass as external
    return Napi::External<void>::New(env, result);
  }
}

Napi::Value Wrap_BundleRef_get_appstream(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected BundleRef instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakBundleRef* self = info[0].As<Napi::External<FlatpakBundleRef>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid BundleRef instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  GBytes* result = flatpak_bundle_ref_get_appstream(self);

  // Return GObject of type GLib.Bytes
  if (!result) {
    return env.Null();
  }
  // Increment reference count for GObject
  if (G_IS_OBJECT(result)) {
    g_object_ref(result);
    // Create external with finalizer
    return Napi::External<void>::New(env, result,
      [](Napi::Env env, void* obj) {
        if (obj && G_IS_OBJECT(obj)) {
          g_object_unref(static_cast<GObject*>(obj));
        }
      });
  } else {
    // Not a GObject, just pass as external
    return Napi::External<void>::New(env, result);
  }
}

Napi::Value Wrap_BundleRef_get_file(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected BundleRef instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakBundleRef* self = info[0].As<Napi::External<FlatpakBundleRef>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid BundleRef instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  GFile* result = flatpak_bundle_ref_get_file(self);

  // Return GObject of type Gio.File
  if (!result) {
    return env.Null();
  }
  // Increment reference count for GObject
  if (G_IS_OBJECT(result)) {
    g_object_ref(result);
    // Create external with finalizer
    return Napi::External<void>::New(env, result,
      [](Napi::Env env, void* obj) {
        if (obj && G_IS_OBJECT(obj)) {
          g_object_unref(static_cast<GObject*>(obj));
        }
      });
  } else {
    // Not a GObject, just pass as external
    return Napi::External<void>::New(env, result);
  }
}

Napi::Value Wrap_BundleRef_get_icon(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected BundleRef instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakBundleRef* self = info[0].As<Napi::External<FlatpakBundleRef>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid BundleRef instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsNumber()) {
    Napi::TypeError::New(env, "Expected number for parameter 'size'").ThrowAsJavaScriptException();
    return env.Null();
  }
  int size = info[1].As<Napi::Number>().Int32Value();

  GBytes* result = flatpak_bundle_ref_get_icon(self, size);

  // Return GObject of type GLib.Bytes
  if (!result) {
    return env.Null();
  }
  // Increment reference count for GObject
  if (G_IS_OBJECT(result)) {
    g_object_ref(result);
    // Create external with finalizer
    return Napi::External<void>::New(env, result,
      [](Napi::Env env, void* obj) {
        if (obj && G_IS_OBJECT(obj)) {
          g_object_unref(static_cast<GObject*>(obj));
        }
      });
  } else {
    // Not a GObject, just pass as external
    return Napi::External<void>::New(env, result);
  }
}

Napi::Value Wrap_BundleRef_get_installed_size(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected BundleRef instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakBundleRef* self = info[0].As<Napi::External<FlatpakBundleRef>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid BundleRef instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  guint64 result = flatpak_bundle_ref_get_installed_size(self);

  return Napi::Number::New(env, result);
}

Napi::Value Wrap_BundleRef_get_metadata(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected BundleRef instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakBundleRef* self = info[0].As<Napi::External<FlatpakBundleRef>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid BundleRef instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  GBytes* result = flatpak_bundle_ref_get_metadata(self);

  // Return GObject of type GLib.Bytes
  if (!result) {
    return env.Null();
  }
  // Increment reference count for GObject
  if (G_IS_OBJECT(result)) {
    g_object_ref(result);
    // Create external with finalizer
    return Napi::External<void>::New(env, result,
      [](Napi::Env env, void* obj) {
        if (obj && G_IS_OBJECT(obj)) {
          g_object_unref(static_cast<GObject*>(obj));
        }
      });
  } else {
    // Not a GObject, just pass as external
    return Napi::External<void>::New(env, result);
  }
}

Napi::Value Wrap_BundleRef_get_origin(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected BundleRef instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakBundleRef* self = info[0].As<Napi::External<FlatpakBundleRef>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid BundleRef instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  char* result = flatpak_bundle_ref_get_origin(self);

  Napi::String js_result = Napi::String::New(env, result ? result : "");
  g_free(result);
  return js_result;
}

Napi::Value Wrap_BundleRef_get_runtime_repo_url(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected BundleRef instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakBundleRef* self = info[0].As<Napi::External<FlatpakBundleRef>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid BundleRef instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  char* result = flatpak_bundle_ref_get_runtime_repo_url(self);

  Napi::String js_result = Napi::String::New(env, result ? result : "");
  g_free(result);
  return js_result;
}

Napi::Value Wrap_Installation_new_for_path(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() <= 0 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected external object for parameter 'path'").ThrowAsJavaScriptException();
    return env.Null();
  }
  GFile* path = info[0].As<Napi::External<GFile>>().Data();

  if (info.Length() <= 1 || !info[1].IsBoolean()) {
    Napi::TypeError::New(env, "Expected boolean for parameter 'user'").ThrowAsJavaScriptException();
    return env.Null();
  }
  gboolean user = info[1].As<Napi::Boolean>().Value();

  GCancellable* cancellable = NULL;
  if (info.Length() > 2 && !info[2].IsNull() && !info[2].IsUndefined()) {
    if (!info[2].IsExternal()) {
      Napi::TypeError::New(env, "Expected external object or null for parameter 'cancellable'").ThrowAsJavaScriptException();
      return env.Null();
    }
    cancellable = info[2].As<Napi::External<GCancellable>>().Data();
  }

  GError* error = NULL;
  FlatpakInstallation* result = flatpak_installation_new_for_path(path, user, cancellable, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  // Return GObject of type Installation
  if (!result) {
    return env.Null();
  }
  // Increment reference count for GObject
  if (G_IS_OBJECT(result)) {
    g_object_ref(result);
    // Create external with finalizer
    return Napi::External<void>::New(env, result,
      [](Napi::Env env, void* obj) {
        if (obj && G_IS_OBJECT(obj)) {
          g_object_unref(static_cast<GObject*>(obj));
        }
      });
  } else {
    // Not a GObject, just pass as external
    return Napi::External<void>::New(env, result);
  }
}

Napi::Value Wrap_Installation_new_system(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  GCancellable* cancellable = NULL;
  if (info.Length() > 0 && !info[0].IsNull() && !info[0].IsUndefined()) {
    if (!info[0].IsExternal()) {
      Napi::TypeError::New(env, "Expected external object or null for parameter 'cancellable'").ThrowAsJavaScriptException();
      return env.Null();
    }
    cancellable = info[0].As<Napi::External<GCancellable>>().Data();
  }

  GError* error = NULL;
  FlatpakInstallation* result = flatpak_installation_new_system(cancellable, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  // Return GObject of type Installation
  if (!result) {
    return env.Null();
  }
  // Increment reference count for GObject
  if (G_IS_OBJECT(result)) {
    g_object_ref(result);
    // Create external with finalizer
    return Napi::External<void>::New(env, result,
      [](Napi::Env env, void* obj) {
        if (obj && G_IS_OBJECT(obj)) {
          g_object_unref(static_cast<GObject*>(obj));
        }
      });
  } else {
    // Not a GObject, just pass as external
    return Napi::External<void>::New(env, result);
  }
}

Napi::Value Wrap_Installation_new_system_with_id(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  const char* id = NULL;
  if (info.Length() > 0 && !info[0].IsNull() && !info[0].IsUndefined()) {
    if (!info[0].IsString()) {
      Napi::TypeError::New(env, "Expected string or null for parameter 'id'").ThrowAsJavaScriptException();
      return env.Null();
    }
    std::string id_str = info[0].As<Napi::String>().Utf8Value();
    id = id_str.c_str();
  }

  GCancellable* cancellable = NULL;
  if (info.Length() > 1 && !info[1].IsNull() && !info[1].IsUndefined()) {
    if (!info[1].IsExternal()) {
      Napi::TypeError::New(env, "Expected external object or null for parameter 'cancellable'").ThrowAsJavaScriptException();
      return env.Null();
    }
    cancellable = info[1].As<Napi::External<GCancellable>>().Data();
  }

  GError* error = NULL;
  FlatpakInstallation* result = flatpak_installation_new_system_with_id(id, cancellable, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  // Return GObject of type Installation
  if (!result) {
    return env.Null();
  }
  // Increment reference count for GObject
  if (G_IS_OBJECT(result)) {
    g_object_ref(result);
    // Create external with finalizer
    return Napi::External<void>::New(env, result,
      [](Napi::Env env, void* obj) {
        if (obj && G_IS_OBJECT(obj)) {
          g_object_unref(static_cast<GObject*>(obj));
        }
      });
  } else {
    // Not a GObject, just pass as external
    return Napi::External<void>::New(env, result);
  }
}

Napi::Value Wrap_Installation_new_user(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  GCancellable* cancellable = NULL;
  if (info.Length() > 0 && !info[0].IsNull() && !info[0].IsUndefined()) {
    if (!info[0].IsExternal()) {
      Napi::TypeError::New(env, "Expected external object or null for parameter 'cancellable'").ThrowAsJavaScriptException();
      return env.Null();
    }
    cancellable = info[0].As<Napi::External<GCancellable>>().Data();
  }

  GError* error = NULL;
  FlatpakInstallation* result = flatpak_installation_new_user(cancellable, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  // Return GObject of type Installation
  if (!result) {
    return env.Null();
  }
  // Increment reference count for GObject
  if (G_IS_OBJECT(result)) {
    g_object_ref(result);
    // Create external with finalizer
    return Napi::External<void>::New(env, result,
      [](Napi::Env env, void* obj) {
        if (obj && G_IS_OBJECT(obj)) {
          g_object_unref(static_cast<GObject*>(obj));
        }
      });
  } else {
    // Not a GObject, just pass as external
    return Napi::External<void>::New(env, result);
  }
}

Napi::Value Wrap_Installation_add_remote(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Installation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstallation* self = info[0].As<Napi::External<FlatpakInstallation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Installation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsExternal()) {
    Napi::TypeError::New(env, "Expected external object for parameter 'remote'").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRemote* remote = info[1].As<Napi::External<FlatpakRemote>>().Data();

  if (info.Length() <= 2 || !info[2].IsBoolean()) {
    Napi::TypeError::New(env, "Expected boolean for parameter 'if_needed'").ThrowAsJavaScriptException();
    return env.Null();
  }
  gboolean if_needed = info[2].As<Napi::Boolean>().Value();

  GCancellable* cancellable = NULL;
  if (info.Length() > 3 && !info[3].IsNull() && !info[3].IsUndefined()) {
    if (!info[3].IsExternal()) {
      Napi::TypeError::New(env, "Expected external object or null for parameter 'cancellable'").ThrowAsJavaScriptException();
      return env.Null();
    }
    cancellable = info[3].As<Napi::External<GCancellable>>().Data();
  }

  GError* error = NULL;
  gboolean result = flatpak_installation_add_remote(self, remote, if_needed, cancellable, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  return Napi::Boolean::New(env, result);
}

Napi::Value Wrap_Installation_cleanup_local_refs_sync(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Installation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstallation* self = info[0].As<Napi::External<FlatpakInstallation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Installation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  GCancellable* cancellable = NULL;
  if (info.Length() > 1 && !info[1].IsNull() && !info[1].IsUndefined()) {
    if (!info[1].IsExternal()) {
      Napi::TypeError::New(env, "Expected external object or null for parameter 'cancellable'").ThrowAsJavaScriptException();
      return env.Null();
    }
    cancellable = info[1].As<Napi::External<GCancellable>>().Data();
  }

  GError* error = NULL;
  gboolean result = flatpak_installation_cleanup_local_refs_sync(self, cancellable, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  return Napi::Boolean::New(env, result);
}

Napi::Value Wrap_Installation_create_monitor(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Installation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstallation* self = info[0].As<Napi::External<FlatpakInstallation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Installation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  GCancellable* cancellable = NULL;
  if (info.Length() > 1 && !info[1].IsNull() && !info[1].IsUndefined()) {
    if (!info[1].IsExternal()) {
      Napi::TypeError::New(env, "Expected external object or null for parameter 'cancellable'").ThrowAsJavaScriptException();
      return env.Null();
    }
    cancellable = info[1].As<Napi::External<GCancellable>>().Data();
  }

  GError* error = NULL;
  GFileMonitor* result = flatpak_installation_create_monitor(self, cancellable, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  // Return GObject of type Gio.FileMonitor
  if (!result) {
    return env.Null();
  }
  // Increment reference count for GObject
  if (G_IS_OBJECT(result)) {
    g_object_ref(result);
    // Create external with finalizer
    return Napi::External<void>::New(env, result,
      [](Napi::Env env, void* obj) {
        if (obj && G_IS_OBJECT(obj)) {
          g_object_unref(static_cast<GObject*>(obj));
        }
      });
  } else {
    // Not a GObject, just pass as external
    return Napi::External<void>::New(env, result);
  }
}

Napi::Value Wrap_Installation_drop_caches(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Installation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstallation* self = info[0].As<Napi::External<FlatpakInstallation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Installation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  GCancellable* cancellable = NULL;
  if (info.Length() > 1 && !info[1].IsNull() && !info[1].IsUndefined()) {
    if (!info[1].IsExternal()) {
      Napi::TypeError::New(env, "Expected external object or null for parameter 'cancellable'").ThrowAsJavaScriptException();
      return env.Null();
    }
    cancellable = info[1].As<Napi::External<GCancellable>>().Data();
  }

  GError* error = NULL;
  gboolean result = flatpak_installation_drop_caches(self, cancellable, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  return Napi::Boolean::New(env, result);
}

Napi::Value Wrap_Installation_fetch_remote_metadata_sync(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Installation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstallation* self = info[0].As<Napi::External<FlatpakInstallation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Installation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsString()) {
    Napi::TypeError::New(env, "Expected string for parameter 'remote_name'").ThrowAsJavaScriptException();
    return env.Null();
  }
  std::string remote_name_str = info[1].As<Napi::String>().Utf8Value();
  const char* remote_name = remote_name_str.c_str();

  if (info.Length() <= 2 || !info[2].IsExternal()) {
    Napi::TypeError::New(env, "Expected external object for parameter 'ref'").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRef* ref = info[2].As<Napi::External<FlatpakRef>>().Data();

  GCancellable* cancellable = NULL;
  if (info.Length() > 3 && !info[3].IsNull() && !info[3].IsUndefined()) {
    if (!info[3].IsExternal()) {
      Napi::TypeError::New(env, "Expected external object or null for parameter 'cancellable'").ThrowAsJavaScriptException();
      return env.Null();
    }
    cancellable = info[3].As<Napi::External<GCancellable>>().Data();
  }

  GError* error = NULL;
  GBytes* result = flatpak_installation_fetch_remote_metadata_sync(self, remote_name, ref, cancellable, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  // Return GObject of type GLib.Bytes
  if (!result) {
    return env.Null();
  }
  // Increment reference count for GObject
  if (G_IS_OBJECT(result)) {
    g_object_ref(result);
    // Create external with finalizer
    return Napi::External<void>::New(env, result,
      [](Napi::Env env, void* obj) {
        if (obj && G_IS_OBJECT(obj)) {
          g_object_unref(static_cast<GObject*>(obj));
        }
      });
  } else {
    // Not a GObject, just pass as external
    return Napi::External<void>::New(env, result);
  }
}

Napi::Value Wrap_Installation_fetch_remote_ref_sync(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Installation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstallation* self = info[0].As<Napi::External<FlatpakInstallation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Installation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsString()) {
    Napi::TypeError::New(env, "Expected string for parameter 'remote_name'").ThrowAsJavaScriptException();
    return env.Null();
  }
  std::string remote_name_str = info[1].As<Napi::String>().Utf8Value();
  const char* remote_name = remote_name_str.c_str();

  if (info.Length() <= 2 || !info[2].IsNumber()) {
    Napi::TypeError::New(env, "Expected number for enum parameter 'kind'").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRefKind kind = static_cast<FlatpakRefKind>(info[2].As<Napi::Number>().Int32Value());

  if (info.Length() <= 3 || !info[3].IsString()) {
    Napi::TypeError::New(env, "Expected string for parameter 'name'").ThrowAsJavaScriptException();
    return env.Null();
  }
  std::string name_str = info[3].As<Napi::String>().Utf8Value();
  const char* name = name_str.c_str();

  const char* arch = NULL;
  if (info.Length() > 4 && !info[4].IsNull() && !info[4].IsUndefined()) {
    if (!info[4].IsString()) {
      Napi::TypeError::New(env, "Expected string or null for parameter 'arch'").ThrowAsJavaScriptException();
      return env.Null();
    }
    std::string arch_str = info[4].As<Napi::String>().Utf8Value();
    arch = arch_str.c_str();
  }

  const char* branch = NULL;
  if (info.Length() > 5 && !info[5].IsNull() && !info[5].IsUndefined()) {
    if (!info[5].IsString()) {
      Napi::TypeError::New(env, "Expected string or null for parameter 'branch'").ThrowAsJavaScriptException();
      return env.Null();
    }
    std::string branch_str = info[5].As<Napi::String>().Utf8Value();
    branch = branch_str.c_str();
  }

  GCancellable* cancellable = NULL;
  if (info.Length() > 6 && !info[6].IsNull() && !info[6].IsUndefined()) {
    if (!info[6].IsExternal()) {
      Napi::TypeError::New(env, "Expected external object or null for parameter 'cancellable'").ThrowAsJavaScriptException();
      return env.Null();
    }
    cancellable = info[6].As<Napi::External<GCancellable>>().Data();
  }

  GError* error = NULL;
  FlatpakRemoteRef* result = flatpak_installation_fetch_remote_ref_sync(self, remote_name, kind, name, arch, branch, cancellable, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  // Return GObject of type RemoteRef
  if (!result) {
    return env.Null();
  }
  // Increment reference count for GObject
  if (G_IS_OBJECT(result)) {
    g_object_ref(result);
    // Create external with finalizer
    return Napi::External<void>::New(env, result,
      [](Napi::Env env, void* obj) {
        if (obj && G_IS_OBJECT(obj)) {
          g_object_unref(static_cast<GObject*>(obj));
        }
      });
  } else {
    // Not a GObject, just pass as external
    return Napi::External<void>::New(env, result);
  }
}

Napi::Value Wrap_Installation_fetch_remote_ref_sync_full(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Installation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstallation* self = info[0].As<Napi::External<FlatpakInstallation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Installation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsString()) {
    Napi::TypeError::New(env, "Expected string for parameter 'remote_name'").ThrowAsJavaScriptException();
    return env.Null();
  }
  std::string remote_name_str = info[1].As<Napi::String>().Utf8Value();
  const char* remote_name = remote_name_str.c_str();

  if (info.Length() <= 2 || !info[2].IsNumber()) {
    Napi::TypeError::New(env, "Expected number for enum parameter 'kind'").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRefKind kind = static_cast<FlatpakRefKind>(info[2].As<Napi::Number>().Int32Value());

  if (info.Length() <= 3 || !info[3].IsString()) {
    Napi::TypeError::New(env, "Expected string for parameter 'name'").ThrowAsJavaScriptException();
    return env.Null();
  }
  std::string name_str = info[3].As<Napi::String>().Utf8Value();
  const char* name = name_str.c_str();

  const char* arch = NULL;
  if (info.Length() > 4 && !info[4].IsNull() && !info[4].IsUndefined()) {
    if (!info[4].IsString()) {
      Napi::TypeError::New(env, "Expected string or null for parameter 'arch'").ThrowAsJavaScriptException();
      return env.Null();
    }
    std::string arch_str = info[4].As<Napi::String>().Utf8Value();
    arch = arch_str.c_str();
  }

  const char* branch = NULL;
  if (info.Length() > 5 && !info[5].IsNull() && !info[5].IsUndefined()) {
    if (!info[5].IsString()) {
      Napi::TypeError::New(env, "Expected string or null for parameter 'branch'").ThrowAsJavaScriptException();
      return env.Null();
    }
    std::string branch_str = info[5].As<Napi::String>().Utf8Value();
    branch = branch_str.c_str();
  }

  if (info.Length() <= 6 || !info[6].IsNumber()) {
    Napi::TypeError::New(env, "Expected number for enum parameter 'flags'").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakQueryFlags flags = static_cast<FlatpakQueryFlags>(info[6].As<Napi::Number>().Int32Value());

  GCancellable* cancellable = NULL;
  if (info.Length() > 7 && !info[7].IsNull() && !info[7].IsUndefined()) {
    if (!info[7].IsExternal()) {
      Napi::TypeError::New(env, "Expected external object or null for parameter 'cancellable'").ThrowAsJavaScriptException();
      return env.Null();
    }
    cancellable = info[7].As<Napi::External<GCancellable>>().Data();
  }

  GError* error = NULL;
  FlatpakRemoteRef* result = flatpak_installation_fetch_remote_ref_sync_full(self, remote_name, kind, name, arch, branch, flags, cancellable, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  // Return GObject of type RemoteRef
  if (!result) {
    return env.Null();
  }
  // Increment reference count for GObject
  if (G_IS_OBJECT(result)) {
    g_object_ref(result);
    // Create external with finalizer
    return Napi::External<void>::New(env, result,
      [](Napi::Env env, void* obj) {
        if (obj && G_IS_OBJECT(obj)) {
          g_object_unref(static_cast<GObject*>(obj));
        }
      });
  } else {
    // Not a GObject, just pass as external
    return Napi::External<void>::New(env, result);
  }
}

Napi::Value Wrap_Installation_fetch_remote_size_sync(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Installation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstallation* self = info[0].As<Napi::External<FlatpakInstallation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Installation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsString()) {
    Napi::TypeError::New(env, "Expected string for parameter 'remote_name'").ThrowAsJavaScriptException();
    return env.Null();
  }
  std::string remote_name_str = info[1].As<Napi::String>().Utf8Value();
  const char* remote_name = remote_name_str.c_str();

  if (info.Length() <= 2 || !info[2].IsExternal()) {
    Napi::TypeError::New(env, "Expected external object for parameter 'ref'").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRef* ref = info[2].As<Napi::External<FlatpakRef>>().Data();

  guint64 download_size_local;
  guint64* download_size = &download_size_local;
  guint64 installed_size_local;
  guint64* installed_size = &installed_size_local;
  GCancellable* cancellable = NULL;
  if (info.Length() > 5 && !info[5].IsNull() && !info[5].IsUndefined()) {
    if (!info[5].IsExternal()) {
      Napi::TypeError::New(env, "Expected external object or null for parameter 'cancellable'").ThrowAsJavaScriptException();
      return env.Null();
    }
    cancellable = info[5].As<Napi::External<GCancellable>>().Data();
  }

  GError* error = NULL;
  gboolean result = flatpak_installation_fetch_remote_size_sync(self, remote_name, ref, download_size, installed_size, cancellable, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  return Napi::Boolean::New(env, result);
}

Napi::Value Wrap_Installation_get_config(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Installation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstallation* self = info[0].As<Napi::External<FlatpakInstallation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Installation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsString()) {
    Napi::TypeError::New(env, "Expected string for parameter 'key'").ThrowAsJavaScriptException();
    return env.Null();
  }
  std::string key_str = info[1].As<Napi::String>().Utf8Value();
  const char* key = key_str.c_str();

  GCancellable* cancellable = NULL;
  if (info.Length() > 2 && !info[2].IsNull() && !info[2].IsUndefined()) {
    if (!info[2].IsExternal()) {
      Napi::TypeError::New(env, "Expected external object or null for parameter 'cancellable'").ThrowAsJavaScriptException();
      return env.Null();
    }
    cancellable = info[2].As<Napi::External<GCancellable>>().Data();
  }

  GError* error = NULL;
  char* result = flatpak_installation_get_config(self, key, cancellable, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  Napi::String js_result = Napi::String::New(env, result ? result : "");
  g_free(result);
  return js_result;
}

Napi::Value Wrap_Installation_get_current_installed_app(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Installation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstallation* self = info[0].As<Napi::External<FlatpakInstallation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Installation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsString()) {
    Napi::TypeError::New(env, "Expected string for parameter 'name'").ThrowAsJavaScriptException();
    return env.Null();
  }
  std::string name_str = info[1].As<Napi::String>().Utf8Value();
  const char* name = name_str.c_str();

  GCancellable* cancellable = NULL;
  if (info.Length() > 2 && !info[2].IsNull() && !info[2].IsUndefined()) {
    if (!info[2].IsExternal()) {
      Napi::TypeError::New(env, "Expected external object or null for parameter 'cancellable'").ThrowAsJavaScriptException();
      return env.Null();
    }
    cancellable = info[2].As<Napi::External<GCancellable>>().Data();
  }

  GError* error = NULL;
  FlatpakInstalledRef* result = flatpak_installation_get_current_installed_app(self, name, cancellable, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  // Return GObject of type InstalledRef
  if (!result) {
    return env.Null();
  }
  // Increment reference count for GObject
  if (G_IS_OBJECT(result)) {
    g_object_ref(result);
    // Create external with finalizer
    return Napi::External<void>::New(env, result,
      [](Napi::Env env, void* obj) {
        if (obj && G_IS_OBJECT(obj)) {
          g_object_unref(static_cast<GObject*>(obj));
        }
      });
  } else {
    // Not a GObject, just pass as external
    return Napi::External<void>::New(env, result);
  }
}

Napi::Value Wrap_Installation_get_default_languages(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Installation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstallation* self = info[0].As<Napi::External<FlatpakInstallation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Installation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  GError* error = NULL;
  char** result = flatpak_installation_get_default_languages(self, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  // Convert string array (GLib.Strv) to JavaScript array
  Napi::Array js_array = Napi::Array::New(env);
  if (result) {
    int i = 0;
    while (result[i]) {
      js_array.Set(i, Napi::String::New(env, result[i]));
      i++;
    }
  }
  g_strfreev(result);
  return js_array;
}

Napi::Value Wrap_Installation_get_default_locales(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Installation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstallation* self = info[0].As<Napi::External<FlatpakInstallation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Installation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  GError* error = NULL;
  char** result = flatpak_installation_get_default_locales(self, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  // Convert string array (GLib.Strv) to JavaScript array
  Napi::Array js_array = Napi::Array::New(env);
  if (result) {
    int i = 0;
    while (result[i]) {
      js_array.Set(i, Napi::String::New(env, result[i]));
      i++;
    }
  }
  g_strfreev(result);
  return js_array;
}

Napi::Value Wrap_Installation_get_display_name(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Installation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstallation* self = info[0].As<Napi::External<FlatpakInstallation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Installation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  const char* result = flatpak_installation_get_display_name(self);

  return Napi::String::New(env, result ? result : "");
}

Napi::Value Wrap_Installation_get_id(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Installation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstallation* self = info[0].As<Napi::External<FlatpakInstallation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Installation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  const char* result = flatpak_installation_get_id(self);

  return Napi::String::New(env, result ? result : "");
}

Napi::Value Wrap_Installation_get_installed_ref(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Installation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstallation* self = info[0].As<Napi::External<FlatpakInstallation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Installation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsNumber()) {
    Napi::TypeError::New(env, "Expected number for enum parameter 'kind'").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRefKind kind = static_cast<FlatpakRefKind>(info[1].As<Napi::Number>().Int32Value());

  if (info.Length() <= 2 || !info[2].IsString()) {
    Napi::TypeError::New(env, "Expected string for parameter 'name'").ThrowAsJavaScriptException();
    return env.Null();
  }
  std::string name_str = info[2].As<Napi::String>().Utf8Value();
  const char* name = name_str.c_str();

  const char* arch = NULL;
  if (info.Length() > 3 && !info[3].IsNull() && !info[3].IsUndefined()) {
    if (!info[3].IsString()) {
      Napi::TypeError::New(env, "Expected string or null for parameter 'arch'").ThrowAsJavaScriptException();
      return env.Null();
    }
    std::string arch_str = info[3].As<Napi::String>().Utf8Value();
    arch = arch_str.c_str();
  }

  const char* branch = NULL;
  if (info.Length() > 4 && !info[4].IsNull() && !info[4].IsUndefined()) {
    if (!info[4].IsString()) {
      Napi::TypeError::New(env, "Expected string or null for parameter 'branch'").ThrowAsJavaScriptException();
      return env.Null();
    }
    std::string branch_str = info[4].As<Napi::String>().Utf8Value();
    branch = branch_str.c_str();
  }

  GCancellable* cancellable = NULL;
  if (info.Length() > 5 && !info[5].IsNull() && !info[5].IsUndefined()) {
    if (!info[5].IsExternal()) {
      Napi::TypeError::New(env, "Expected external object or null for parameter 'cancellable'").ThrowAsJavaScriptException();
      return env.Null();
    }
    cancellable = info[5].As<Napi::External<GCancellable>>().Data();
  }

  GError* error = NULL;
  FlatpakInstalledRef* result = flatpak_installation_get_installed_ref(self, kind, name, arch, branch, cancellable, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  // Return GObject of type InstalledRef
  if (!result) {
    return env.Null();
  }
  // Increment reference count for GObject
  if (G_IS_OBJECT(result)) {
    g_object_ref(result);
    // Create external with finalizer
    return Napi::External<void>::New(env, result,
      [](Napi::Env env, void* obj) {
        if (obj && G_IS_OBJECT(obj)) {
          g_object_unref(static_cast<GObject*>(obj));
        }
      });
  } else {
    // Not a GObject, just pass as external
    return Napi::External<void>::New(env, result);
  }
}

Napi::Value Wrap_Installation_get_is_user(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Installation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstallation* self = info[0].As<Napi::External<FlatpakInstallation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Installation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  gboolean result = flatpak_installation_get_is_user(self);

  return Napi::Boolean::New(env, result);
}

Napi::Value Wrap_Installation_get_min_free_space_bytes(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Installation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstallation* self = info[0].As<Napi::External<FlatpakInstallation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Installation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  guint64 out_bytes_local;
  guint64* out_bytes = &out_bytes_local;
  GError* error = NULL;
  gboolean result = flatpak_installation_get_min_free_space_bytes(self, out_bytes, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  return Napi::Boolean::New(env, result);
}

Napi::Value Wrap_Installation_get_no_interaction(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Installation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstallation* self = info[0].As<Napi::External<FlatpakInstallation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Installation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  gboolean result = flatpak_installation_get_no_interaction(self);

  return Napi::Boolean::New(env, result);
}

Napi::Value Wrap_Installation_get_path(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Installation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstallation* self = info[0].As<Napi::External<FlatpakInstallation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Installation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  GFile* result = flatpak_installation_get_path(self);

  // Return GObject of type Gio.File
  if (!result) {
    return env.Null();
  }
  // Increment reference count for GObject
  if (G_IS_OBJECT(result)) {
    g_object_ref(result);
    // Create external with finalizer
    return Napi::External<void>::New(env, result,
      [](Napi::Env env, void* obj) {
        if (obj && G_IS_OBJECT(obj)) {
          g_object_unref(static_cast<GObject*>(obj));
        }
      });
  } else {
    // Not a GObject, just pass as external
    return Napi::External<void>::New(env, result);
  }
}

Napi::Value Wrap_Installation_get_priority(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Installation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstallation* self = info[0].As<Napi::External<FlatpakInstallation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Installation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  gint result = flatpak_installation_get_priority(self);

  return Napi::Number::New(env, result);
}

Napi::Value Wrap_Installation_get_remote_by_name(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Installation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstallation* self = info[0].As<Napi::External<FlatpakInstallation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Installation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsString()) {
    Napi::TypeError::New(env, "Expected string for parameter 'name'").ThrowAsJavaScriptException();
    return env.Null();
  }
  std::string name_str = info[1].As<Napi::String>().Utf8Value();
  const char* name = name_str.c_str();

  GCancellable* cancellable = NULL;
  if (info.Length() > 2 && !info[2].IsNull() && !info[2].IsUndefined()) {
    if (!info[2].IsExternal()) {
      Napi::TypeError::New(env, "Expected external object or null for parameter 'cancellable'").ThrowAsJavaScriptException();
      return env.Null();
    }
    cancellable = info[2].As<Napi::External<GCancellable>>().Data();
  }

  GError* error = NULL;
  FlatpakRemote* result = flatpak_installation_get_remote_by_name(self, name, cancellable, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  // Return GObject of type Remote
  if (!result) {
    return env.Null();
  }
  // Increment reference count for GObject
  if (G_IS_OBJECT(result)) {
    g_object_ref(result);
    // Create external with finalizer
    return Napi::External<void>::New(env, result,
      [](Napi::Env env, void* obj) {
        if (obj && G_IS_OBJECT(obj)) {
          g_object_unref(static_cast<GObject*>(obj));
        }
      });
  } else {
    // Not a GObject, just pass as external
    return Napi::External<void>::New(env, result);
  }
}

Napi::Value Wrap_Installation_get_storage_type(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Installation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstallation* self = info[0].As<Napi::External<FlatpakInstallation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Installation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  FlatpakStorageType result = flatpak_installation_get_storage_type(self);

  return Napi::Number::New(env, static_cast<int32_t>(result));
}

Napi::Value Wrap_Installation_install_ref_file(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Installation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstallation* self = info[0].As<Napi::External<FlatpakInstallation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Installation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsExternal()) {
    Napi::TypeError::New(env, "Expected external object for parameter 'ref_file_data'").ThrowAsJavaScriptException();
    return env.Null();
  }
  GBytes* ref_file_data = info[1].As<Napi::External<GBytes>>().Data();

  GCancellable* cancellable = NULL;
  if (info.Length() > 2 && !info[2].IsNull() && !info[2].IsUndefined()) {
    if (!info[2].IsExternal()) {
      Napi::TypeError::New(env, "Expected external object or null for parameter 'cancellable'").ThrowAsJavaScriptException();
      return env.Null();
    }
    cancellable = info[2].As<Napi::External<GCancellable>>().Data();
  }

  GError* error = NULL;
  FlatpakRemoteRef* result = flatpak_installation_install_ref_file(self, ref_file_data, cancellable, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  // Return GObject of type RemoteRef
  if (!result) {
    return env.Null();
  }
  // Increment reference count for GObject
  if (G_IS_OBJECT(result)) {
    g_object_ref(result);
    // Create external with finalizer
    return Napi::External<void>::New(env, result,
      [](Napi::Env env, void* obj) {
        if (obj && G_IS_OBJECT(obj)) {
          g_object_unref(static_cast<GObject*>(obj));
        }
      });
  } else {
    // Not a GObject, just pass as external
    return Napi::External<void>::New(env, result);
  }
}

Napi::Value Wrap_Installation_launch(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Installation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstallation* self = info[0].As<Napi::External<FlatpakInstallation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Installation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsString()) {
    Napi::TypeError::New(env, "Expected string for parameter 'name'").ThrowAsJavaScriptException();
    return env.Null();
  }
  std::string name_str = info[1].As<Napi::String>().Utf8Value();
  const char* name = name_str.c_str();

  const char* arch = NULL;
  if (info.Length() > 2 && !info[2].IsNull() && !info[2].IsUndefined()) {
    if (!info[2].IsString()) {
      Napi::TypeError::New(env, "Expected string or null for parameter 'arch'").ThrowAsJavaScriptException();
      return env.Null();
    }
    std::string arch_str = info[2].As<Napi::String>().Utf8Value();
    arch = arch_str.c_str();
  }

  const char* branch = NULL;
  if (info.Length() > 3 && !info[3].IsNull() && !info[3].IsUndefined()) {
    if (!info[3].IsString()) {
      Napi::TypeError::New(env, "Expected string or null for parameter 'branch'").ThrowAsJavaScriptException();
      return env.Null();
    }
    std::string branch_str = info[3].As<Napi::String>().Utf8Value();
    branch = branch_str.c_str();
  }

  const char* commit = NULL;
  if (info.Length() > 4 && !info[4].IsNull() && !info[4].IsUndefined()) {
    if (!info[4].IsString()) {
      Napi::TypeError::New(env, "Expected string or null for parameter 'commit'").ThrowAsJavaScriptException();
      return env.Null();
    }
    std::string commit_str = info[4].As<Napi::String>().Utf8Value();
    commit = commit_str.c_str();
  }

  GCancellable* cancellable = NULL;
  if (info.Length() > 5 && !info[5].IsNull() && !info[5].IsUndefined()) {
    if (!info[5].IsExternal()) {
      Napi::TypeError::New(env, "Expected external object or null for parameter 'cancellable'").ThrowAsJavaScriptException();
      return env.Null();
    }
    cancellable = info[5].As<Napi::External<GCancellable>>().Data();
  }

  GError* error = NULL;
  gboolean result = flatpak_installation_launch(self, name, arch, branch, commit, cancellable, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  return Napi::Boolean::New(env, result);
}

Napi::Value Wrap_Installation_launch_full(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Installation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstallation* self = info[0].As<Napi::External<FlatpakInstallation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Installation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsNumber()) {
    Napi::TypeError::New(env, "Expected number for enum parameter 'flags'").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakLaunchFlags flags = static_cast<FlatpakLaunchFlags>(info[1].As<Napi::Number>().Int32Value());

  if (info.Length() <= 2 || !info[2].IsString()) {
    Napi::TypeError::New(env, "Expected string for parameter 'name'").ThrowAsJavaScriptException();
    return env.Null();
  }
  std::string name_str = info[2].As<Napi::String>().Utf8Value();
  const char* name = name_str.c_str();

  const char* arch = NULL;
  if (info.Length() > 3 && !info[3].IsNull() && !info[3].IsUndefined()) {
    if (!info[3].IsString()) {
      Napi::TypeError::New(env, "Expected string or null for parameter 'arch'").ThrowAsJavaScriptException();
      return env.Null();
    }
    std::string arch_str = info[3].As<Napi::String>().Utf8Value();
    arch = arch_str.c_str();
  }

  const char* branch = NULL;
  if (info.Length() > 4 && !info[4].IsNull() && !info[4].IsUndefined()) {
    if (!info[4].IsString()) {
      Napi::TypeError::New(env, "Expected string or null for parameter 'branch'").ThrowAsJavaScriptException();
      return env.Null();
    }
    std::string branch_str = info[4].As<Napi::String>().Utf8Value();
    branch = branch_str.c_str();
  }

  const char* commit = NULL;
  if (info.Length() > 5 && !info[5].IsNull() && !info[5].IsUndefined()) {
    if (!info[5].IsString()) {
      Napi::TypeError::New(env, "Expected string or null for parameter 'commit'").ThrowAsJavaScriptException();
      return env.Null();
    }
    std::string commit_str = info[5].As<Napi::String>().Utf8Value();
    commit = commit_str.c_str();
  }

  FlatpakInstance* instance_out_local = NULL;
  FlatpakInstance** instance_out = &instance_out_local;
  GCancellable* cancellable = NULL;
  if (info.Length() > 7 && !info[7].IsNull() && !info[7].IsUndefined()) {
    if (!info[7].IsExternal()) {
      Napi::TypeError::New(env, "Expected external object or null for parameter 'cancellable'").ThrowAsJavaScriptException();
      return env.Null();
    }
    cancellable = info[7].As<Napi::External<GCancellable>>().Data();
  }

  GError* error = NULL;
  gboolean result = flatpak_installation_launch_full(self, flags, name, arch, branch, commit, instance_out, cancellable, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  return Napi::Boolean::New(env, result);
}

Napi::Value Wrap_Installation_list_installed_refs(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Installation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstallation* self = info[0].As<Napi::External<FlatpakInstallation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Installation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  GCancellable* cancellable = NULL;
  if (info.Length() > 1 && !info[1].IsNull() && !info[1].IsUndefined()) {
    if (!info[1].IsExternal()) {
      Napi::TypeError::New(env, "Expected external object or null for parameter 'cancellable'").ThrowAsJavaScriptException();
      return env.Null();
    }
    cancellable = info[1].As<Napi::External<GCancellable>>().Data();
  }

  GError* error = NULL;
  GPtrArray* result = flatpak_installation_list_installed_refs(self, cancellable, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  // Convert GPtrArray to JavaScript array
  Napi::Array js_array = Napi::Array::New(env);
  if (result) {
    GPtrArray* array = result;
    for (guint i = 0; i < array->len; i++) {
      gpointer item = g_ptr_array_index(array, i);
      if (!item) {
        js_array.Set(i, env.Null());
        continue;
      }
      FlatpakInstalledRef* typed_item = static_cast<FlatpakInstalledRef*>(item);
      if (!typed_item) {
        js_array.Set(i, env.Null());
        continue;
      }
      // Increment reference count for GObject
      if (G_IS_OBJECT(typed_item)) {
        g_object_ref(typed_item);
        // Create external with finalizer
        js_array.Set(i, Napi::External<FlatpakInstalledRef>::New(env, typed_item,
          [](Napi::Env env, FlatpakInstalledRef* obj) {
            if (obj && G_IS_OBJECT(obj)) {
              g_object_unref(obj);
            }
          }));
      } else {
        // Not a GObject, just pass as external
        js_array.Set(i, Napi::External<FlatpakInstalledRef>::New(env, typed_item));
      }
    }
    // Unref the array but not the contained objects
    g_ptr_array_unref(result);
  }
  return js_array;
}

Napi::Value Wrap_Installation_list_installed_refs_by_kind(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Installation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstallation* self = info[0].As<Napi::External<FlatpakInstallation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Installation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsNumber()) {
    Napi::TypeError::New(env, "Expected number for enum parameter 'kind'").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRefKind kind = static_cast<FlatpakRefKind>(info[1].As<Napi::Number>().Int32Value());

  GCancellable* cancellable = NULL;
  if (info.Length() > 2 && !info[2].IsNull() && !info[2].IsUndefined()) {
    if (!info[2].IsExternal()) {
      Napi::TypeError::New(env, "Expected external object or null for parameter 'cancellable'").ThrowAsJavaScriptException();
      return env.Null();
    }
    cancellable = info[2].As<Napi::External<GCancellable>>().Data();
  }

  GError* error = NULL;
  GPtrArray* result = flatpak_installation_list_installed_refs_by_kind(self, kind, cancellable, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  // Convert GPtrArray to JavaScript array
  Napi::Array js_array = Napi::Array::New(env);
  if (result) {
    GPtrArray* array = result;
    for (guint i = 0; i < array->len; i++) {
      gpointer item = g_ptr_array_index(array, i);
      if (!item) {
        js_array.Set(i, env.Null());
        continue;
      }
      FlatpakInstalledRef* typed_item = static_cast<FlatpakInstalledRef*>(item);
      if (!typed_item) {
        js_array.Set(i, env.Null());
        continue;
      }
      // Increment reference count for GObject
      if (G_IS_OBJECT(typed_item)) {
        g_object_ref(typed_item);
        // Create external with finalizer
        js_array.Set(i, Napi::External<FlatpakInstalledRef>::New(env, typed_item,
          [](Napi::Env env, FlatpakInstalledRef* obj) {
            if (obj && G_IS_OBJECT(obj)) {
              g_object_unref(obj);
            }
          }));
      } else {
        // Not a GObject, just pass as external
        js_array.Set(i, Napi::External<FlatpakInstalledRef>::New(env, typed_item));
      }
    }
    // Unref the array but not the contained objects
    g_ptr_array_unref(result);
  }
  return js_array;
}

Napi::Value Wrap_Installation_list_installed_refs_for_update(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Installation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstallation* self = info[0].As<Napi::External<FlatpakInstallation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Installation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  GCancellable* cancellable = NULL;
  if (info.Length() > 1 && !info[1].IsNull() && !info[1].IsUndefined()) {
    if (!info[1].IsExternal()) {
      Napi::TypeError::New(env, "Expected external object or null for parameter 'cancellable'").ThrowAsJavaScriptException();
      return env.Null();
    }
    cancellable = info[1].As<Napi::External<GCancellable>>().Data();
  }

  GError* error = NULL;
  GPtrArray* result = flatpak_installation_list_installed_refs_for_update(self, cancellable, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  // Convert GPtrArray to JavaScript array
  Napi::Array js_array = Napi::Array::New(env);
  if (result) {
    GPtrArray* array = result;
    for (guint i = 0; i < array->len; i++) {
      gpointer item = g_ptr_array_index(array, i);
      if (!item) {
        js_array.Set(i, env.Null());
        continue;
      }
      FlatpakInstalledRef* typed_item = static_cast<FlatpakInstalledRef*>(item);
      if (!typed_item) {
        js_array.Set(i, env.Null());
        continue;
      }
      // Increment reference count for GObject
      if (G_IS_OBJECT(typed_item)) {
        g_object_ref(typed_item);
        // Create external with finalizer
        js_array.Set(i, Napi::External<FlatpakInstalledRef>::New(env, typed_item,
          [](Napi::Env env, FlatpakInstalledRef* obj) {
            if (obj && G_IS_OBJECT(obj)) {
              g_object_unref(obj);
            }
          }));
      } else {
        // Not a GObject, just pass as external
        js_array.Set(i, Napi::External<FlatpakInstalledRef>::New(env, typed_item));
      }
    }
    // Unref the array but not the contained objects
    g_ptr_array_unref(result);
  }
  return js_array;
}

Napi::Value Wrap_Installation_list_installed_related_refs_sync(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Installation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstallation* self = info[0].As<Napi::External<FlatpakInstallation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Installation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsString()) {
    Napi::TypeError::New(env, "Expected string for parameter 'remote_name'").ThrowAsJavaScriptException();
    return env.Null();
  }
  std::string remote_name_str = info[1].As<Napi::String>().Utf8Value();
  const char* remote_name = remote_name_str.c_str();

  if (info.Length() <= 2 || !info[2].IsString()) {
    Napi::TypeError::New(env, "Expected string for parameter 'ref'").ThrowAsJavaScriptException();
    return env.Null();
  }
  std::string ref_str = info[2].As<Napi::String>().Utf8Value();
  const char* ref = ref_str.c_str();

  GCancellable* cancellable = NULL;
  if (info.Length() > 3 && !info[3].IsNull() && !info[3].IsUndefined()) {
    if (!info[3].IsExternal()) {
      Napi::TypeError::New(env, "Expected external object or null for parameter 'cancellable'").ThrowAsJavaScriptException();
      return env.Null();
    }
    cancellable = info[3].As<Napi::External<GCancellable>>().Data();
  }

  GError* error = NULL;
  GPtrArray* result = flatpak_installation_list_installed_related_refs_sync(self, remote_name, ref, cancellable, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  // Convert GPtrArray to JavaScript array
  Napi::Array js_array = Napi::Array::New(env);
  if (result) {
    GPtrArray* array = result;
    for (guint i = 0; i < array->len; i++) {
      gpointer item = g_ptr_array_index(array, i);
      if (!item) {
        js_array.Set(i, env.Null());
        continue;
      }
      FlatpakRelatedRef* typed_item = static_cast<FlatpakRelatedRef*>(item);
      if (!typed_item) {
        js_array.Set(i, env.Null());
        continue;
      }
      // Increment reference count for GObject
      if (G_IS_OBJECT(typed_item)) {
        g_object_ref(typed_item);
        // Create external with finalizer
        js_array.Set(i, Napi::External<FlatpakRelatedRef>::New(env, typed_item,
          [](Napi::Env env, FlatpakRelatedRef* obj) {
            if (obj && G_IS_OBJECT(obj)) {
              g_object_unref(obj);
            }
          }));
      } else {
        // Not a GObject, just pass as external
        js_array.Set(i, Napi::External<FlatpakRelatedRef>::New(env, typed_item));
      }
    }
    // Unref the array but not the contained objects
    g_ptr_array_unref(result);
  }
  return js_array;
}

Napi::Value Wrap_Installation_list_pinned_refs(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Installation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstallation* self = info[0].As<Napi::External<FlatpakInstallation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Installation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  const char* arch = NULL;
  if (info.Length() > 1 && !info[1].IsNull() && !info[1].IsUndefined()) {
    if (!info[1].IsString()) {
      Napi::TypeError::New(env, "Expected string or null for parameter 'arch'").ThrowAsJavaScriptException();
      return env.Null();
    }
    std::string arch_str = info[1].As<Napi::String>().Utf8Value();
    arch = arch_str.c_str();
  }

  GCancellable* cancellable = NULL;
  if (info.Length() > 2 && !info[2].IsNull() && !info[2].IsUndefined()) {
    if (!info[2].IsExternal()) {
      Napi::TypeError::New(env, "Expected external object or null for parameter 'cancellable'").ThrowAsJavaScriptException();
      return env.Null();
    }
    cancellable = info[2].As<Napi::External<GCancellable>>().Data();
  }

  GError* error = NULL;
  GPtrArray* result = flatpak_installation_list_pinned_refs(self, arch, cancellable, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  // Convert GPtrArray to JavaScript array
  Napi::Array js_array = Napi::Array::New(env);
  if (result) {
    GPtrArray* array = result;
    for (guint i = 0; i < array->len; i++) {
      gpointer item = g_ptr_array_index(array, i);
      if (!item) {
        js_array.Set(i, env.Null());
        continue;
      }
      FlatpakInstalledRef* typed_item = static_cast<FlatpakInstalledRef*>(item);
      if (!typed_item) {
        js_array.Set(i, env.Null());
        continue;
      }
      // Increment reference count for GObject
      if (G_IS_OBJECT(typed_item)) {
        g_object_ref(typed_item);
        // Create external with finalizer
        js_array.Set(i, Napi::External<FlatpakInstalledRef>::New(env, typed_item,
          [](Napi::Env env, FlatpakInstalledRef* obj) {
            if (obj && G_IS_OBJECT(obj)) {
              g_object_unref(obj);
            }
          }));
      } else {
        // Not a GObject, just pass as external
        js_array.Set(i, Napi::External<FlatpakInstalledRef>::New(env, typed_item));
      }
    }
    // Unref the array but not the contained objects
    g_ptr_array_unref(result);
  }
  return js_array;
}

Napi::Value Wrap_Installation_list_remote_refs_sync(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Installation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstallation* self = info[0].As<Napi::External<FlatpakInstallation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Installation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsString()) {
    Napi::TypeError::New(env, "Expected string for parameter 'remote_or_uri'").ThrowAsJavaScriptException();
    return env.Null();
  }
  std::string remote_or_uri_str = info[1].As<Napi::String>().Utf8Value();
  const char* remote_or_uri = remote_or_uri_str.c_str();

  GCancellable* cancellable = NULL;
  if (info.Length() > 2 && !info[2].IsNull() && !info[2].IsUndefined()) {
    if (!info[2].IsExternal()) {
      Napi::TypeError::New(env, "Expected external object or null for parameter 'cancellable'").ThrowAsJavaScriptException();
      return env.Null();
    }
    cancellable = info[2].As<Napi::External<GCancellable>>().Data();
  }

  GError* error = NULL;
  GPtrArray* result = flatpak_installation_list_remote_refs_sync(self, remote_or_uri, cancellable, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  // Convert GPtrArray to JavaScript array
  Napi::Array js_array = Napi::Array::New(env);
  if (result) {
    GPtrArray* array = result;
    for (guint i = 0; i < array->len; i++) {
      gpointer item = g_ptr_array_index(array, i);
      if (!item) {
        js_array.Set(i, env.Null());
        continue;
      }
      FlatpakRemoteRef* typed_item = static_cast<FlatpakRemoteRef*>(item);
      if (!typed_item) {
        js_array.Set(i, env.Null());
        continue;
      }
      // Increment reference count for GObject
      if (G_IS_OBJECT(typed_item)) {
        g_object_ref(typed_item);
        // Create external with finalizer
        js_array.Set(i, Napi::External<FlatpakRemoteRef>::New(env, typed_item,
          [](Napi::Env env, FlatpakRemoteRef* obj) {
            if (obj && G_IS_OBJECT(obj)) {
              g_object_unref(obj);
            }
          }));
      } else {
        // Not a GObject, just pass as external
        js_array.Set(i, Napi::External<FlatpakRemoteRef>::New(env, typed_item));
      }
    }
    // Unref the array but not the contained objects
    g_ptr_array_unref(result);
  }
  return js_array;
}

Napi::Value Wrap_Installation_list_remote_refs_sync_full(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Installation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstallation* self = info[0].As<Napi::External<FlatpakInstallation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Installation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsString()) {
    Napi::TypeError::New(env, "Expected string for parameter 'remote_or_uri'").ThrowAsJavaScriptException();
    return env.Null();
  }
  std::string remote_or_uri_str = info[1].As<Napi::String>().Utf8Value();
  const char* remote_or_uri = remote_or_uri_str.c_str();

  if (info.Length() <= 2 || !info[2].IsNumber()) {
    Napi::TypeError::New(env, "Expected number for enum parameter 'flags'").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakQueryFlags flags = static_cast<FlatpakQueryFlags>(info[2].As<Napi::Number>().Int32Value());

  GCancellable* cancellable = NULL;
  if (info.Length() > 3 && !info[3].IsNull() && !info[3].IsUndefined()) {
    if (!info[3].IsExternal()) {
      Napi::TypeError::New(env, "Expected external object or null for parameter 'cancellable'").ThrowAsJavaScriptException();
      return env.Null();
    }
    cancellable = info[3].As<Napi::External<GCancellable>>().Data();
  }

  GError* error = NULL;
  GPtrArray* result = flatpak_installation_list_remote_refs_sync_full(self, remote_or_uri, flags, cancellable, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  // Convert GPtrArray to JavaScript array
  Napi::Array js_array = Napi::Array::New(env);
  if (result) {
    GPtrArray* array = result;
    for (guint i = 0; i < array->len; i++) {
      gpointer item = g_ptr_array_index(array, i);
      if (!item) {
        js_array.Set(i, env.Null());
        continue;
      }
      FlatpakRemoteRef* typed_item = static_cast<FlatpakRemoteRef*>(item);
      if (!typed_item) {
        js_array.Set(i, env.Null());
        continue;
      }
      // Increment reference count for GObject
      if (G_IS_OBJECT(typed_item)) {
        g_object_ref(typed_item);
        // Create external with finalizer
        js_array.Set(i, Napi::External<FlatpakRemoteRef>::New(env, typed_item,
          [](Napi::Env env, FlatpakRemoteRef* obj) {
            if (obj && G_IS_OBJECT(obj)) {
              g_object_unref(obj);
            }
          }));
      } else {
        // Not a GObject, just pass as external
        js_array.Set(i, Napi::External<FlatpakRemoteRef>::New(env, typed_item));
      }
    }
    // Unref the array but not the contained objects
    g_ptr_array_unref(result);
  }
  return js_array;
}

Napi::Value Wrap_Installation_list_remote_related_refs_for_installed_sync(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Installation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstallation* self = info[0].As<Napi::External<FlatpakInstallation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Installation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsString()) {
    Napi::TypeError::New(env, "Expected string for parameter 'remote_name'").ThrowAsJavaScriptException();
    return env.Null();
  }
  std::string remote_name_str = info[1].As<Napi::String>().Utf8Value();
  const char* remote_name = remote_name_str.c_str();

  if (info.Length() <= 2 || !info[2].IsString()) {
    Napi::TypeError::New(env, "Expected string for parameter 'ref'").ThrowAsJavaScriptException();
    return env.Null();
  }
  std::string ref_str = info[2].As<Napi::String>().Utf8Value();
  const char* ref = ref_str.c_str();

  GCancellable* cancellable = NULL;
  if (info.Length() > 3 && !info[3].IsNull() && !info[3].IsUndefined()) {
    if (!info[3].IsExternal()) {
      Napi::TypeError::New(env, "Expected external object or null for parameter 'cancellable'").ThrowAsJavaScriptException();
      return env.Null();
    }
    cancellable = info[3].As<Napi::External<GCancellable>>().Data();
  }

  GError* error = NULL;
  GPtrArray* result = flatpak_installation_list_remote_related_refs_for_installed_sync(self, remote_name, ref, cancellable, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  // Convert GPtrArray to JavaScript array
  Napi::Array js_array = Napi::Array::New(env);
  if (result) {
    GPtrArray* array = result;
    for (guint i = 0; i < array->len; i++) {
      gpointer item = g_ptr_array_index(array, i);
      if (!item) {
        js_array.Set(i, env.Null());
        continue;
      }
      FlatpakRelatedRef* typed_item = static_cast<FlatpakRelatedRef*>(item);
      if (!typed_item) {
        js_array.Set(i, env.Null());
        continue;
      }
      // Increment reference count for GObject
      if (G_IS_OBJECT(typed_item)) {
        g_object_ref(typed_item);
        // Create external with finalizer
        js_array.Set(i, Napi::External<FlatpakRelatedRef>::New(env, typed_item,
          [](Napi::Env env, FlatpakRelatedRef* obj) {
            if (obj && G_IS_OBJECT(obj)) {
              g_object_unref(obj);
            }
          }));
      } else {
        // Not a GObject, just pass as external
        js_array.Set(i, Napi::External<FlatpakRelatedRef>::New(env, typed_item));
      }
    }
    // Unref the array but not the contained objects
    g_ptr_array_unref(result);
  }
  return js_array;
}

Napi::Value Wrap_Installation_list_remote_related_refs_sync(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Installation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstallation* self = info[0].As<Napi::External<FlatpakInstallation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Installation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsString()) {
    Napi::TypeError::New(env, "Expected string for parameter 'remote_name'").ThrowAsJavaScriptException();
    return env.Null();
  }
  std::string remote_name_str = info[1].As<Napi::String>().Utf8Value();
  const char* remote_name = remote_name_str.c_str();

  if (info.Length() <= 2 || !info[2].IsString()) {
    Napi::TypeError::New(env, "Expected string for parameter 'ref'").ThrowAsJavaScriptException();
    return env.Null();
  }
  std::string ref_str = info[2].As<Napi::String>().Utf8Value();
  const char* ref = ref_str.c_str();

  GCancellable* cancellable = NULL;
  if (info.Length() > 3 && !info[3].IsNull() && !info[3].IsUndefined()) {
    if (!info[3].IsExternal()) {
      Napi::TypeError::New(env, "Expected external object or null for parameter 'cancellable'").ThrowAsJavaScriptException();
      return env.Null();
    }
    cancellable = info[3].As<Napi::External<GCancellable>>().Data();
  }

  GError* error = NULL;
  GPtrArray* result = flatpak_installation_list_remote_related_refs_sync(self, remote_name, ref, cancellable, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  // Convert GPtrArray to JavaScript array
  Napi::Array js_array = Napi::Array::New(env);
  if (result) {
    GPtrArray* array = result;
    for (guint i = 0; i < array->len; i++) {
      gpointer item = g_ptr_array_index(array, i);
      if (!item) {
        js_array.Set(i, env.Null());
        continue;
      }
      FlatpakRelatedRef* typed_item = static_cast<FlatpakRelatedRef*>(item);
      if (!typed_item) {
        js_array.Set(i, env.Null());
        continue;
      }
      // Increment reference count for GObject
      if (G_IS_OBJECT(typed_item)) {
        g_object_ref(typed_item);
        // Create external with finalizer
        js_array.Set(i, Napi::External<FlatpakRelatedRef>::New(env, typed_item,
          [](Napi::Env env, FlatpakRelatedRef* obj) {
            if (obj && G_IS_OBJECT(obj)) {
              g_object_unref(obj);
            }
          }));
      } else {
        // Not a GObject, just pass as external
        js_array.Set(i, Napi::External<FlatpakRelatedRef>::New(env, typed_item));
      }
    }
    // Unref the array but not the contained objects
    g_ptr_array_unref(result);
  }
  return js_array;
}

Napi::Value Wrap_Installation_list_remotes(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Installation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstallation* self = info[0].As<Napi::External<FlatpakInstallation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Installation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  GCancellable* cancellable = NULL;
  if (info.Length() > 1 && !info[1].IsNull() && !info[1].IsUndefined()) {
    if (!info[1].IsExternal()) {
      Napi::TypeError::New(env, "Expected external object or null for parameter 'cancellable'").ThrowAsJavaScriptException();
      return env.Null();
    }
    cancellable = info[1].As<Napi::External<GCancellable>>().Data();
  }

  GError* error = NULL;
  GPtrArray* result = flatpak_installation_list_remotes(self, cancellable, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  // Convert GPtrArray to JavaScript array
  Napi::Array js_array = Napi::Array::New(env);
  if (result) {
    GPtrArray* array = result;
    for (guint i = 0; i < array->len; i++) {
      gpointer item = g_ptr_array_index(array, i);
      if (!item) {
        js_array.Set(i, env.Null());
        continue;
      }
      FlatpakRemote* typed_item = static_cast<FlatpakRemote*>(item);
      if (!typed_item) {
        js_array.Set(i, env.Null());
        continue;
      }
      // Increment reference count for GObject
      if (G_IS_OBJECT(typed_item)) {
        g_object_ref(typed_item);
        // Create external with finalizer
        js_array.Set(i, Napi::External<FlatpakRemote>::New(env, typed_item,
          [](Napi::Env env, FlatpakRemote* obj) {
            if (obj && G_IS_OBJECT(obj)) {
              g_object_unref(obj);
            }
          }));
      } else {
        // Not a GObject, just pass as external
        js_array.Set(i, Napi::External<FlatpakRemote>::New(env, typed_item));
      }
    }
    // Unref the array but not the contained objects
    g_ptr_array_unref(result);
  }
  return js_array;
}

Napi::Value Wrap_Installation_list_unused_refs(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Installation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstallation* self = info[0].As<Napi::External<FlatpakInstallation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Installation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  const char* arch = NULL;
  if (info.Length() > 1 && !info[1].IsNull() && !info[1].IsUndefined()) {
    if (!info[1].IsString()) {
      Napi::TypeError::New(env, "Expected string or null for parameter 'arch'").ThrowAsJavaScriptException();
      return env.Null();
    }
    std::string arch_str = info[1].As<Napi::String>().Utf8Value();
    arch = arch_str.c_str();
  }

  GCancellable* cancellable = NULL;
  if (info.Length() > 2 && !info[2].IsNull() && !info[2].IsUndefined()) {
    if (!info[2].IsExternal()) {
      Napi::TypeError::New(env, "Expected external object or null for parameter 'cancellable'").ThrowAsJavaScriptException();
      return env.Null();
    }
    cancellable = info[2].As<Napi::External<GCancellable>>().Data();
  }

  GError* error = NULL;
  GPtrArray* result = flatpak_installation_list_unused_refs(self, arch, cancellable, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  // Convert GPtrArray to JavaScript array
  Napi::Array js_array = Napi::Array::New(env);
  if (result) {
    GPtrArray* array = result;
    for (guint i = 0; i < array->len; i++) {
      gpointer item = g_ptr_array_index(array, i);
      if (!item) {
        js_array.Set(i, env.Null());
        continue;
      }
      FlatpakInstalledRef* typed_item = static_cast<FlatpakInstalledRef*>(item);
      if (!typed_item) {
        js_array.Set(i, env.Null());
        continue;
      }
      // Increment reference count for GObject
      if (G_IS_OBJECT(typed_item)) {
        g_object_ref(typed_item);
        // Create external with finalizer
        js_array.Set(i, Napi::External<FlatpakInstalledRef>::New(env, typed_item,
          [](Napi::Env env, FlatpakInstalledRef* obj) {
            if (obj && G_IS_OBJECT(obj)) {
              g_object_unref(obj);
            }
          }));
      } else {
        // Not a GObject, just pass as external
        js_array.Set(i, Napi::External<FlatpakInstalledRef>::New(env, typed_item));
      }
    }
    // Unref the array but not the contained objects
    g_ptr_array_unref(result);
  }
  return js_array;
}

Napi::Value Wrap_Installation_list_unused_refs_with_options(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Installation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstallation* self = info[0].As<Napi::External<FlatpakInstallation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Installation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  const char* arch = NULL;
  if (info.Length() > 1 && !info[1].IsNull() && !info[1].IsUndefined()) {
    if (!info[1].IsString()) {
      Napi::TypeError::New(env, "Expected string or null for parameter 'arch'").ThrowAsJavaScriptException();
      return env.Null();
    }
    std::string arch_str = info[1].As<Napi::String>().Utf8Value();
    arch = arch_str.c_str();
  }

  GHashTable* metadata_injection = NULL;
  if (info.Length() > 2 && !info[2].IsNull() && !info[2].IsUndefined()) {
    if (!info[2].IsExternal()) {
      Napi::TypeError::New(env, "Expected external object or null for parameter 'metadata_injection'").ThrowAsJavaScriptException();
      return env.Null();
    }
    metadata_injection = info[2].As<Napi::External<GHashTable>>().Data();
  }

  GVariant* options = NULL;
  if (info.Length() > 3 && !info[3].IsNull() && !info[3].IsUndefined()) {
    if (!info[3].IsExternal()) {
      Napi::TypeError::New(env, "Expected external object or null for parameter 'options'").ThrowAsJavaScriptException();
      return env.Null();
    }
    options = info[3].As<Napi::External<GVariant>>().Data();
  }

  GCancellable* cancellable = NULL;
  if (info.Length() > 4 && !info[4].IsNull() && !info[4].IsUndefined()) {
    if (!info[4].IsExternal()) {
      Napi::TypeError::New(env, "Expected external object or null for parameter 'cancellable'").ThrowAsJavaScriptException();
      return env.Null();
    }
    cancellable = info[4].As<Napi::External<GCancellable>>().Data();
  }

  GError* error = NULL;
  GPtrArray* result = flatpak_installation_list_unused_refs_with_options(self, arch, metadata_injection, options, cancellable, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  // Convert GPtrArray to JavaScript array
  Napi::Array js_array = Napi::Array::New(env);
  if (result) {
    GPtrArray* array = result;
    for (guint i = 0; i < array->len; i++) {
      gpointer item = g_ptr_array_index(array, i);
      if (!item) {
        js_array.Set(i, env.Null());
        continue;
      }
      FlatpakInstalledRef* typed_item = static_cast<FlatpakInstalledRef*>(item);
      if (!typed_item) {
        js_array.Set(i, env.Null());
        continue;
      }
      // Increment reference count for GObject
      if (G_IS_OBJECT(typed_item)) {
        g_object_ref(typed_item);
        // Create external with finalizer
        js_array.Set(i, Napi::External<FlatpakInstalledRef>::New(env, typed_item,
          [](Napi::Env env, FlatpakInstalledRef* obj) {
            if (obj && G_IS_OBJECT(obj)) {
              g_object_unref(obj);
            }
          }));
      } else {
        // Not a GObject, just pass as external
        js_array.Set(i, Napi::External<FlatpakInstalledRef>::New(env, typed_item));
      }
    }
    // Unref the array but not the contained objects
    g_ptr_array_unref(result);
  }
  return js_array;
}

Napi::Value Wrap_Installation_load_app_overrides(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Installation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstallation* self = info[0].As<Napi::External<FlatpakInstallation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Installation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsString()) {
    Napi::TypeError::New(env, "Expected string for parameter 'app_id'").ThrowAsJavaScriptException();
    return env.Null();
  }
  std::string app_id_str = info[1].As<Napi::String>().Utf8Value();
  const char* app_id = app_id_str.c_str();

  GCancellable* cancellable = NULL;
  if (info.Length() > 2 && !info[2].IsNull() && !info[2].IsUndefined()) {
    if (!info[2].IsExternal()) {
      Napi::TypeError::New(env, "Expected external object or null for parameter 'cancellable'").ThrowAsJavaScriptException();
      return env.Null();
    }
    cancellable = info[2].As<Napi::External<GCancellable>>().Data();
  }

  GError* error = NULL;
  char* result = flatpak_installation_load_app_overrides(self, app_id, cancellable, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  Napi::String js_result = Napi::String::New(env, result ? result : "");
  g_free(result);
  return js_result;
}

Napi::Value Wrap_Installation_modify_remote(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Installation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstallation* self = info[0].As<Napi::External<FlatpakInstallation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Installation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsExternal()) {
    Napi::TypeError::New(env, "Expected external object for parameter 'remote'").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRemote* remote = info[1].As<Napi::External<FlatpakRemote>>().Data();

  GCancellable* cancellable = NULL;
  if (info.Length() > 2 && !info[2].IsNull() && !info[2].IsUndefined()) {
    if (!info[2].IsExternal()) {
      Napi::TypeError::New(env, "Expected external object or null for parameter 'cancellable'").ThrowAsJavaScriptException();
      return env.Null();
    }
    cancellable = info[2].As<Napi::External<GCancellable>>().Data();
  }

  GError* error = NULL;
  gboolean result = flatpak_installation_modify_remote(self, remote, cancellable, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  return Napi::Boolean::New(env, result);
}

Napi::Value Wrap_Installation_prune_local_repo(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Installation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstallation* self = info[0].As<Napi::External<FlatpakInstallation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Installation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  GCancellable* cancellable = NULL;
  if (info.Length() > 1 && !info[1].IsNull() && !info[1].IsUndefined()) {
    if (!info[1].IsExternal()) {
      Napi::TypeError::New(env, "Expected external object or null for parameter 'cancellable'").ThrowAsJavaScriptException();
      return env.Null();
    }
    cancellable = info[1].As<Napi::External<GCancellable>>().Data();
  }

  GError* error = NULL;
  gboolean result = flatpak_installation_prune_local_repo(self, cancellable, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  return Napi::Boolean::New(env, result);
}

Napi::Value Wrap_Installation_remove_local_ref_sync(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Installation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstallation* self = info[0].As<Napi::External<FlatpakInstallation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Installation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsString()) {
    Napi::TypeError::New(env, "Expected string for parameter 'remote_name'").ThrowAsJavaScriptException();
    return env.Null();
  }
  std::string remote_name_str = info[1].As<Napi::String>().Utf8Value();
  const char* remote_name = remote_name_str.c_str();

  if (info.Length() <= 2 || !info[2].IsString()) {
    Napi::TypeError::New(env, "Expected string for parameter 'ref'").ThrowAsJavaScriptException();
    return env.Null();
  }
  std::string ref_str = info[2].As<Napi::String>().Utf8Value();
  const char* ref = ref_str.c_str();

  GCancellable* cancellable = NULL;
  if (info.Length() > 3 && !info[3].IsNull() && !info[3].IsUndefined()) {
    if (!info[3].IsExternal()) {
      Napi::TypeError::New(env, "Expected external object or null for parameter 'cancellable'").ThrowAsJavaScriptException();
      return env.Null();
    }
    cancellable = info[3].As<Napi::External<GCancellable>>().Data();
  }

  GError* error = NULL;
  gboolean result = flatpak_installation_remove_local_ref_sync(self, remote_name, ref, cancellable, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  return Napi::Boolean::New(env, result);
}

Napi::Value Wrap_Installation_remove_remote(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Installation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstallation* self = info[0].As<Napi::External<FlatpakInstallation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Installation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsString()) {
    Napi::TypeError::New(env, "Expected string for parameter 'name'").ThrowAsJavaScriptException();
    return env.Null();
  }
  std::string name_str = info[1].As<Napi::String>().Utf8Value();
  const char* name = name_str.c_str();

  GCancellable* cancellable = NULL;
  if (info.Length() > 2 && !info[2].IsNull() && !info[2].IsUndefined()) {
    if (!info[2].IsExternal()) {
      Napi::TypeError::New(env, "Expected external object or null for parameter 'cancellable'").ThrowAsJavaScriptException();
      return env.Null();
    }
    cancellable = info[2].As<Napi::External<GCancellable>>().Data();
  }

  GError* error = NULL;
  gboolean result = flatpak_installation_remove_remote(self, name, cancellable, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  return Napi::Boolean::New(env, result);
}

Napi::Value Wrap_Installation_run_triggers(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Installation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstallation* self = info[0].As<Napi::External<FlatpakInstallation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Installation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  GCancellable* cancellable = NULL;
  if (info.Length() > 1 && !info[1].IsNull() && !info[1].IsUndefined()) {
    if (!info[1].IsExternal()) {
      Napi::TypeError::New(env, "Expected external object or null for parameter 'cancellable'").ThrowAsJavaScriptException();
      return env.Null();
    }
    cancellable = info[1].As<Napi::External<GCancellable>>().Data();
  }

  GError* error = NULL;
  gboolean result = flatpak_installation_run_triggers(self, cancellable, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  return Napi::Boolean::New(env, result);
}

Napi::Value Wrap_Installation_set_config_sync(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Installation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstallation* self = info[0].As<Napi::External<FlatpakInstallation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Installation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsString()) {
    Napi::TypeError::New(env, "Expected string for parameter 'key'").ThrowAsJavaScriptException();
    return env.Null();
  }
  std::string key_str = info[1].As<Napi::String>().Utf8Value();
  const char* key = key_str.c_str();

  if (info.Length() <= 2 || !info[2].IsString()) {
    Napi::TypeError::New(env, "Expected string for parameter 'value'").ThrowAsJavaScriptException();
    return env.Null();
  }
  std::string value_str = info[2].As<Napi::String>().Utf8Value();
  const char* value = value_str.c_str();

  GCancellable* cancellable = NULL;
  if (info.Length() > 3 && !info[3].IsNull() && !info[3].IsUndefined()) {
    if (!info[3].IsExternal()) {
      Napi::TypeError::New(env, "Expected external object or null for parameter 'cancellable'").ThrowAsJavaScriptException();
      return env.Null();
    }
    cancellable = info[3].As<Napi::External<GCancellable>>().Data();
  }

  GError* error = NULL;
  gboolean result = flatpak_installation_set_config_sync(self, key, value, cancellable, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  return Napi::Boolean::New(env, result);
}

Napi::Value Wrap_Installation_set_no_interaction(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Installation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstallation* self = info[0].As<Napi::External<FlatpakInstallation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Installation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsBoolean()) {
    Napi::TypeError::New(env, "Expected boolean for parameter 'no_interaction'").ThrowAsJavaScriptException();
    return env.Null();
  }
  gboolean no_interaction = info[1].As<Napi::Boolean>().Value();

  flatpak_installation_set_no_interaction(self, no_interaction);

  return env.Undefined();
}

Napi::Value Wrap_Installation_update_appstream_sync(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Installation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstallation* self = info[0].As<Napi::External<FlatpakInstallation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Installation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsString()) {
    Napi::TypeError::New(env, "Expected string for parameter 'remote_name'").ThrowAsJavaScriptException();
    return env.Null();
  }
  std::string remote_name_str = info[1].As<Napi::String>().Utf8Value();
  const char* remote_name = remote_name_str.c_str();

  const char* arch = NULL;
  if (info.Length() > 2 && !info[2].IsNull() && !info[2].IsUndefined()) {
    if (!info[2].IsString()) {
      Napi::TypeError::New(env, "Expected string or null for parameter 'arch'").ThrowAsJavaScriptException();
      return env.Null();
    }
    std::string arch_str = info[2].As<Napi::String>().Utf8Value();
    arch = arch_str.c_str();
  }

  gboolean out_changed_local;
  gboolean* out_changed = &out_changed_local;
  GCancellable* cancellable = NULL;
  if (info.Length() > 4 && !info[4].IsNull() && !info[4].IsUndefined()) {
    if (!info[4].IsExternal()) {
      Napi::TypeError::New(env, "Expected external object or null for parameter 'cancellable'").ThrowAsJavaScriptException();
      return env.Null();
    }
    cancellable = info[4].As<Napi::External<GCancellable>>().Data();
  }

  GError* error = NULL;
  gboolean result = flatpak_installation_update_appstream_sync(self, remote_name, arch, out_changed, cancellable, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  return Napi::Boolean::New(env, result);
}

Napi::Value Wrap_Installation_update_remote_sync(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Installation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstallation* self = info[0].As<Napi::External<FlatpakInstallation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Installation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsString()) {
    Napi::TypeError::New(env, "Expected string for parameter 'name'").ThrowAsJavaScriptException();
    return env.Null();
  }
  std::string name_str = info[1].As<Napi::String>().Utf8Value();
  const char* name = name_str.c_str();

  GCancellable* cancellable = NULL;
  if (info.Length() > 2 && !info[2].IsNull() && !info[2].IsUndefined()) {
    if (!info[2].IsExternal()) {
      Napi::TypeError::New(env, "Expected external object or null for parameter 'cancellable'").ThrowAsJavaScriptException();
      return env.Null();
    }
    cancellable = info[2].As<Napi::External<GCancellable>>().Data();
  }

  GError* error = NULL;
  gboolean result = flatpak_installation_update_remote_sync(self, name, cancellable, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  return Napi::Boolean::New(env, result);
}

Napi::Value Wrap_InstalledRef_get_appdata_content_rating(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected InstalledRef instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstalledRef* self = info[0].As<Napi::External<FlatpakInstalledRef>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid InstalledRef instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  GHashTable* result = flatpak_installed_ref_get_appdata_content_rating(self);

  // Return GObject of type GLib.HashTable
  if (!result) {
    return env.Null();
  }
  // Increment reference count for GObject
  if (G_IS_OBJECT(result)) {
    g_object_ref(result);
    // Create external with finalizer
    return Napi::External<void>::New(env, result,
      [](Napi::Env env, void* obj) {
        if (obj && G_IS_OBJECT(obj)) {
          g_object_unref(static_cast<GObject*>(obj));
        }
      });
  } else {
    // Not a GObject, just pass as external
    return Napi::External<void>::New(env, result);
  }
}

Napi::Value Wrap_InstalledRef_get_appdata_content_rating_type(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected InstalledRef instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstalledRef* self = info[0].As<Napi::External<FlatpakInstalledRef>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid InstalledRef instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  const char* result = flatpak_installed_ref_get_appdata_content_rating_type(self);

  return Napi::String::New(env, result ? result : "");
}

Napi::Value Wrap_InstalledRef_get_appdata_license(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected InstalledRef instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstalledRef* self = info[0].As<Napi::External<FlatpakInstalledRef>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid InstalledRef instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  const char* result = flatpak_installed_ref_get_appdata_license(self);

  return Napi::String::New(env, result ? result : "");
}

Napi::Value Wrap_InstalledRef_get_appdata_name(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected InstalledRef instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstalledRef* self = info[0].As<Napi::External<FlatpakInstalledRef>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid InstalledRef instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  const char* result = flatpak_installed_ref_get_appdata_name(self);

  return Napi::String::New(env, result ? result : "");
}

Napi::Value Wrap_InstalledRef_get_appdata_summary(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected InstalledRef instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstalledRef* self = info[0].As<Napi::External<FlatpakInstalledRef>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid InstalledRef instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  const char* result = flatpak_installed_ref_get_appdata_summary(self);

  return Napi::String::New(env, result ? result : "");
}

Napi::Value Wrap_InstalledRef_get_appdata_version(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected InstalledRef instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstalledRef* self = info[0].As<Napi::External<FlatpakInstalledRef>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid InstalledRef instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  const char* result = flatpak_installed_ref_get_appdata_version(self);

  return Napi::String::New(env, result ? result : "");
}

Napi::Value Wrap_InstalledRef_get_deploy_dir(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected InstalledRef instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstalledRef* self = info[0].As<Napi::External<FlatpakInstalledRef>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid InstalledRef instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  const char* result = flatpak_installed_ref_get_deploy_dir(self);

  return Napi::String::New(env, result ? result : "");
}

Napi::Value Wrap_InstalledRef_get_eol(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected InstalledRef instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstalledRef* self = info[0].As<Napi::External<FlatpakInstalledRef>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid InstalledRef instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  const char* result = flatpak_installed_ref_get_eol(self);

  return Napi::String::New(env, result ? result : "");
}

Napi::Value Wrap_InstalledRef_get_eol_rebase(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected InstalledRef instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstalledRef* self = info[0].As<Napi::External<FlatpakInstalledRef>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid InstalledRef instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  const char* result = flatpak_installed_ref_get_eol_rebase(self);

  return Napi::String::New(env, result ? result : "");
}

Napi::Value Wrap_InstalledRef_get_installed_size(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected InstalledRef instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstalledRef* self = info[0].As<Napi::External<FlatpakInstalledRef>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid InstalledRef instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  guint64 result = flatpak_installed_ref_get_installed_size(self);

  return Napi::Number::New(env, result);
}

Napi::Value Wrap_InstalledRef_get_is_current(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected InstalledRef instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstalledRef* self = info[0].As<Napi::External<FlatpakInstalledRef>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid InstalledRef instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  gboolean result = flatpak_installed_ref_get_is_current(self);

  return Napi::Boolean::New(env, result);
}

Napi::Value Wrap_InstalledRef_get_latest_commit(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected InstalledRef instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstalledRef* self = info[0].As<Napi::External<FlatpakInstalledRef>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid InstalledRef instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  const char* result = flatpak_installed_ref_get_latest_commit(self);

  return Napi::String::New(env, result ? result : "");
}

Napi::Value Wrap_InstalledRef_get_origin(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected InstalledRef instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstalledRef* self = info[0].As<Napi::External<FlatpakInstalledRef>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid InstalledRef instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  const char* result = flatpak_installed_ref_get_origin(self);

  return Napi::String::New(env, result ? result : "");
}

Napi::Value Wrap_InstalledRef_get_subpaths(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected InstalledRef instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstalledRef* self = info[0].As<Napi::External<FlatpakInstalledRef>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid InstalledRef instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  const char* const* result = flatpak_installed_ref_get_subpaths(self);

  // Convert string array (GLib.Strv) to JavaScript array
  Napi::Array js_array = Napi::Array::New(env);
  if (result) {
    int i = 0;
    while (result[i]) {
      js_array.Set(i, Napi::String::New(env, result[i]));
      i++;
    }
  }
  return js_array;
}

Napi::Value Wrap_InstalledRef_load_appdata(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected InstalledRef instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstalledRef* self = info[0].As<Napi::External<FlatpakInstalledRef>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid InstalledRef instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  GCancellable* cancellable = NULL;
  if (info.Length() > 1 && !info[1].IsNull() && !info[1].IsUndefined()) {
    if (!info[1].IsExternal()) {
      Napi::TypeError::New(env, "Expected external object or null for parameter 'cancellable'").ThrowAsJavaScriptException();
      return env.Null();
    }
    cancellable = info[1].As<Napi::External<GCancellable>>().Data();
  }

  GError* error = NULL;
  GBytes* result = flatpak_installed_ref_load_appdata(self, cancellable, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  // Return GObject of type GLib.Bytes
  if (!result) {
    return env.Null();
  }
  // Increment reference count for GObject
  if (G_IS_OBJECT(result)) {
    g_object_ref(result);
    // Create external with finalizer
    return Napi::External<void>::New(env, result,
      [](Napi::Env env, void* obj) {
        if (obj && G_IS_OBJECT(obj)) {
          g_object_unref(static_cast<GObject*>(obj));
        }
      });
  } else {
    // Not a GObject, just pass as external
    return Napi::External<void>::New(env, result);
  }
}

Napi::Value Wrap_InstalledRef_load_metadata(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected InstalledRef instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstalledRef* self = info[0].As<Napi::External<FlatpakInstalledRef>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid InstalledRef instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  GCancellable* cancellable = NULL;
  if (info.Length() > 1 && !info[1].IsNull() && !info[1].IsUndefined()) {
    if (!info[1].IsExternal()) {
      Napi::TypeError::New(env, "Expected external object or null for parameter 'cancellable'").ThrowAsJavaScriptException();
      return env.Null();
    }
    cancellable = info[1].As<Napi::External<GCancellable>>().Data();
  }

  GError* error = NULL;
  GBytes* result = flatpak_installed_ref_load_metadata(self, cancellable, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  // Return GObject of type GLib.Bytes
  if (!result) {
    return env.Null();
  }
  // Increment reference count for GObject
  if (G_IS_OBJECT(result)) {
    g_object_ref(result);
    // Create external with finalizer
    return Napi::External<void>::New(env, result,
      [](Napi::Env env, void* obj) {
        if (obj && G_IS_OBJECT(obj)) {
          g_object_unref(static_cast<GObject*>(obj));
        }
      });
  } else {
    // Not a GObject, just pass as external
    return Napi::External<void>::New(env, result);
  }
}

Napi::Value Wrap_Instance_get_app(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Instance instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstance* self = info[0].As<Napi::External<FlatpakInstance>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Instance instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  const char* result = flatpak_instance_get_app(self);

  return Napi::String::New(env, result ? result : "");
}

Napi::Value Wrap_Instance_get_arch(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Instance instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstance* self = info[0].As<Napi::External<FlatpakInstance>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Instance instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  const char* result = flatpak_instance_get_arch(self);

  return Napi::String::New(env, result ? result : "");
}

Napi::Value Wrap_Instance_get_branch(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Instance instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstance* self = info[0].As<Napi::External<FlatpakInstance>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Instance instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  const char* result = flatpak_instance_get_branch(self);

  return Napi::String::New(env, result ? result : "");
}

Napi::Value Wrap_Instance_get_child_pid(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Instance instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstance* self = info[0].As<Napi::External<FlatpakInstance>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Instance instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  int result = flatpak_instance_get_child_pid(self);

  return Napi::Number::New(env, result);
}

Napi::Value Wrap_Instance_get_commit(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Instance instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstance* self = info[0].As<Napi::External<FlatpakInstance>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Instance instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  const char* result = flatpak_instance_get_commit(self);

  return Napi::String::New(env, result ? result : "");
}

Napi::Value Wrap_Instance_get_id(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Instance instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstance* self = info[0].As<Napi::External<FlatpakInstance>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Instance instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  const char* result = flatpak_instance_get_id(self);

  return Napi::String::New(env, result ? result : "");
}

Napi::Value Wrap_Instance_get_info(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Instance instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstance* self = info[0].As<Napi::External<FlatpakInstance>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Instance instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  GKeyFile* result = flatpak_instance_get_info(self);

  // Return GObject of type GLib.KeyFile
  if (!result) {
    return env.Null();
  }
  // Increment reference count for GObject
  if (G_IS_OBJECT(result)) {
    g_object_ref(result);
    // Create external with finalizer
    return Napi::External<void>::New(env, result,
      [](Napi::Env env, void* obj) {
        if (obj && G_IS_OBJECT(obj)) {
          g_object_unref(static_cast<GObject*>(obj));
        }
      });
  } else {
    // Not a GObject, just pass as external
    return Napi::External<void>::New(env, result);
  }
}

Napi::Value Wrap_Instance_get_pid(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Instance instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstance* self = info[0].As<Napi::External<FlatpakInstance>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Instance instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  int result = flatpak_instance_get_pid(self);

  return Napi::Number::New(env, result);
}

Napi::Value Wrap_Instance_get_runtime(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Instance instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstance* self = info[0].As<Napi::External<FlatpakInstance>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Instance instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  const char* result = flatpak_instance_get_runtime(self);

  return Napi::String::New(env, result ? result : "");
}

Napi::Value Wrap_Instance_get_runtime_commit(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Instance instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstance* self = info[0].As<Napi::External<FlatpakInstance>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Instance instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  const char* result = flatpak_instance_get_runtime_commit(self);

  return Napi::String::New(env, result ? result : "");
}

Napi::Value Wrap_Instance_is_running(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Instance instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstance* self = info[0].As<Napi::External<FlatpakInstance>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Instance instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  gboolean result = flatpak_instance_is_running(self);

  return Napi::Boolean::New(env, result);
}

Napi::Value Wrap_Ref_format_ref(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Ref instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRef* self = info[0].As<Napi::External<FlatpakRef>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Ref instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  char* result = flatpak_ref_format_ref(self);

  Napi::String js_result = Napi::String::New(env, result ? result : "");
  g_free(result);
  return js_result;
}

Napi::Value Wrap_Ref_format_ref_cached(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Ref instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRef* self = info[0].As<Napi::External<FlatpakRef>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Ref instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  const char* result = flatpak_ref_format_ref_cached(self);

  return Napi::String::New(env, result ? result : "");
}

Napi::Value Wrap_Ref_get_arch(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Ref instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRef* self = info[0].As<Napi::External<FlatpakRef>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Ref instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  const char* result = flatpak_ref_get_arch(self);

  return Napi::String::New(env, result ? result : "");
}

Napi::Value Wrap_Ref_get_branch(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Ref instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRef* self = info[0].As<Napi::External<FlatpakRef>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Ref instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  const char* result = flatpak_ref_get_branch(self);

  return Napi::String::New(env, result ? result : "");
}

Napi::Value Wrap_Ref_get_collection_id(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Ref instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRef* self = info[0].As<Napi::External<FlatpakRef>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Ref instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  const char* result = flatpak_ref_get_collection_id(self);

  return Napi::String::New(env, result ? result : "");
}

Napi::Value Wrap_Ref_get_commit(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Ref instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRef* self = info[0].As<Napi::External<FlatpakRef>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Ref instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  const char* result = flatpak_ref_get_commit(self);

  return Napi::String::New(env, result ? result : "");
}

Napi::Value Wrap_Ref_get_kind(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Ref instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRef* self = info[0].As<Napi::External<FlatpakRef>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Ref instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  FlatpakRefKind result = flatpak_ref_get_kind(self);

  return Napi::Number::New(env, static_cast<int32_t>(result));
}

Napi::Value Wrap_Ref_get_name(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Ref instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRef* self = info[0].As<Napi::External<FlatpakRef>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Ref instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  const char* result = flatpak_ref_get_name(self);

  return Napi::String::New(env, result ? result : "");
}

Napi::Value Wrap_RelatedRef_get_subpaths(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected RelatedRef instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRelatedRef* self = info[0].As<Napi::External<FlatpakRelatedRef>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid RelatedRef instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  const char* const* result = flatpak_related_ref_get_subpaths(self);

  // Convert string array (GLib.Strv) to JavaScript array
  Napi::Array js_array = Napi::Array::New(env);
  if (result) {
    int i = 0;
    while (result[i]) {
      js_array.Set(i, Napi::String::New(env, result[i]));
      i++;
    }
  }
  return js_array;
}

Napi::Value Wrap_RelatedRef_should_autoprune(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected RelatedRef instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRelatedRef* self = info[0].As<Napi::External<FlatpakRelatedRef>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid RelatedRef instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  gboolean result = flatpak_related_ref_should_autoprune(self);

  return Napi::Boolean::New(env, result);
}

Napi::Value Wrap_RelatedRef_should_delete(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected RelatedRef instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRelatedRef* self = info[0].As<Napi::External<FlatpakRelatedRef>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid RelatedRef instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  gboolean result = flatpak_related_ref_should_delete(self);

  return Napi::Boolean::New(env, result);
}

Napi::Value Wrap_RelatedRef_should_download(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected RelatedRef instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRelatedRef* self = info[0].As<Napi::External<FlatpakRelatedRef>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid RelatedRef instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  gboolean result = flatpak_related_ref_should_download(self);

  return Napi::Boolean::New(env, result);
}

Napi::Value Wrap_Remote_new(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() <= 0 || !info[0].IsString()) {
    Napi::TypeError::New(env, "Expected string for parameter 'name'").ThrowAsJavaScriptException();
    return env.Null();
  }
  std::string name_str = info[0].As<Napi::String>().Utf8Value();
  const char* name = name_str.c_str();

  FlatpakRemote* result = flatpak_remote_new(name);

  // Return GObject of type Remote
  if (!result) {
    return env.Null();
  }
  // Increment reference count for GObject
  if (G_IS_OBJECT(result)) {
    g_object_ref(result);
    // Create external with finalizer
    return Napi::External<void>::New(env, result,
      [](Napi::Env env, void* obj) {
        if (obj && G_IS_OBJECT(obj)) {
          g_object_unref(static_cast<GObject*>(obj));
        }
      });
  } else {
    // Not a GObject, just pass as external
    return Napi::External<void>::New(env, result);
  }
}

Napi::Value Wrap_Remote_new_from_file(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() <= 0 || !info[0].IsString()) {
    Napi::TypeError::New(env, "Expected string for parameter 'name'").ThrowAsJavaScriptException();
    return env.Null();
  }
  std::string name_str = info[0].As<Napi::String>().Utf8Value();
  const char* name = name_str.c_str();

  if (info.Length() <= 1 || !info[1].IsExternal()) {
    Napi::TypeError::New(env, "Expected external object for parameter 'data'").ThrowAsJavaScriptException();
    return env.Null();
  }
  GBytes* data = info[1].As<Napi::External<GBytes>>().Data();

  GError* error = NULL;
  FlatpakRemote* result = flatpak_remote_new_from_file(name, data, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  // Return GObject of type Remote
  if (!result) {
    return env.Null();
  }
  // Increment reference count for GObject
  if (G_IS_OBJECT(result)) {
    g_object_ref(result);
    // Create external with finalizer
    return Napi::External<void>::New(env, result,
      [](Napi::Env env, void* obj) {
        if (obj && G_IS_OBJECT(obj)) {
          g_object_unref(static_cast<GObject*>(obj));
        }
      });
  } else {
    // Not a GObject, just pass as external
    return Napi::External<void>::New(env, result);
  }
}

Napi::Value Wrap_Remote_get_appstream_dir(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Remote instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRemote* self = info[0].As<Napi::External<FlatpakRemote>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Remote instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  const char* arch = NULL;
  if (info.Length() > 1 && !info[1].IsNull() && !info[1].IsUndefined()) {
    if (!info[1].IsString()) {
      Napi::TypeError::New(env, "Expected string or null for parameter 'arch'").ThrowAsJavaScriptException();
      return env.Null();
    }
    std::string arch_str = info[1].As<Napi::String>().Utf8Value();
    arch = arch_str.c_str();
  }

  GFile* result = flatpak_remote_get_appstream_dir(self, arch);

  // Return GObject of type Gio.File
  if (!result) {
    return env.Null();
  }
  // Increment reference count for GObject
  if (G_IS_OBJECT(result)) {
    g_object_ref(result);
    // Create external with finalizer
    return Napi::External<void>::New(env, result,
      [](Napi::Env env, void* obj) {
        if (obj && G_IS_OBJECT(obj)) {
          g_object_unref(static_cast<GObject*>(obj));
        }
      });
  } else {
    // Not a GObject, just pass as external
    return Napi::External<void>::New(env, result);
  }
}

Napi::Value Wrap_Remote_get_appstream_timestamp(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Remote instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRemote* self = info[0].As<Napi::External<FlatpakRemote>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Remote instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  const char* arch = NULL;
  if (info.Length() > 1 && !info[1].IsNull() && !info[1].IsUndefined()) {
    if (!info[1].IsString()) {
      Napi::TypeError::New(env, "Expected string or null for parameter 'arch'").ThrowAsJavaScriptException();
      return env.Null();
    }
    std::string arch_str = info[1].As<Napi::String>().Utf8Value();
    arch = arch_str.c_str();
  }

  GFile* result = flatpak_remote_get_appstream_timestamp(self, arch);

  // Return GObject of type Gio.File
  if (!result) {
    return env.Null();
  }
  // Increment reference count for GObject
  if (G_IS_OBJECT(result)) {
    g_object_ref(result);
    // Create external with finalizer
    return Napi::External<void>::New(env, result,
      [](Napi::Env env, void* obj) {
        if (obj && G_IS_OBJECT(obj)) {
          g_object_unref(static_cast<GObject*>(obj));
        }
      });
  } else {
    // Not a GObject, just pass as external
    return Napi::External<void>::New(env, result);
  }
}

Napi::Value Wrap_Remote_get_collection_id(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Remote instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRemote* self = info[0].As<Napi::External<FlatpakRemote>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Remote instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  char* result = flatpak_remote_get_collection_id(self);

  Napi::String js_result = Napi::String::New(env, result ? result : "");
  g_free(result);
  return js_result;
}

Napi::Value Wrap_Remote_get_comment(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Remote instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRemote* self = info[0].As<Napi::External<FlatpakRemote>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Remote instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  char* result = flatpak_remote_get_comment(self);

  Napi::String js_result = Napi::String::New(env, result ? result : "");
  g_free(result);
  return js_result;
}

Napi::Value Wrap_Remote_get_default_branch(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Remote instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRemote* self = info[0].As<Napi::External<FlatpakRemote>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Remote instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  char* result = flatpak_remote_get_default_branch(self);

  Napi::String js_result = Napi::String::New(env, result ? result : "");
  g_free(result);
  return js_result;
}

Napi::Value Wrap_Remote_get_description(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Remote instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRemote* self = info[0].As<Napi::External<FlatpakRemote>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Remote instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  char* result = flatpak_remote_get_description(self);

  Napi::String js_result = Napi::String::New(env, result ? result : "");
  g_free(result);
  return js_result;
}

Napi::Value Wrap_Remote_get_disabled(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Remote instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRemote* self = info[0].As<Napi::External<FlatpakRemote>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Remote instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  gboolean result = flatpak_remote_get_disabled(self);

  return Napi::Boolean::New(env, result);
}

Napi::Value Wrap_Remote_get_filter(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Remote instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRemote* self = info[0].As<Napi::External<FlatpakRemote>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Remote instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  char* result = flatpak_remote_get_filter(self);

  Napi::String js_result = Napi::String::New(env, result ? result : "");
  g_free(result);
  return js_result;
}

Napi::Value Wrap_Remote_get_gpg_verify(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Remote instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRemote* self = info[0].As<Napi::External<FlatpakRemote>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Remote instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  gboolean result = flatpak_remote_get_gpg_verify(self);

  return Napi::Boolean::New(env, result);
}

Napi::Value Wrap_Remote_get_homepage(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Remote instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRemote* self = info[0].As<Napi::External<FlatpakRemote>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Remote instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  char* result = flatpak_remote_get_homepage(self);

  Napi::String js_result = Napi::String::New(env, result ? result : "");
  g_free(result);
  return js_result;
}

Napi::Value Wrap_Remote_get_icon(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Remote instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRemote* self = info[0].As<Napi::External<FlatpakRemote>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Remote instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  char* result = flatpak_remote_get_icon(self);

  Napi::String js_result = Napi::String::New(env, result ? result : "");
  g_free(result);
  return js_result;
}

Napi::Value Wrap_Remote_get_main_ref(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Remote instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRemote* self = info[0].As<Napi::External<FlatpakRemote>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Remote instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  char* result = flatpak_remote_get_main_ref(self);

  Napi::String js_result = Napi::String::New(env, result ? result : "");
  g_free(result);
  return js_result;
}

Napi::Value Wrap_Remote_get_name(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Remote instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRemote* self = info[0].As<Napi::External<FlatpakRemote>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Remote instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  const char* result = flatpak_remote_get_name(self);

  return Napi::String::New(env, result ? result : "");
}

Napi::Value Wrap_Remote_get_nodeps(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Remote instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRemote* self = info[0].As<Napi::External<FlatpakRemote>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Remote instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  gboolean result = flatpak_remote_get_nodeps(self);

  return Napi::Boolean::New(env, result);
}

Napi::Value Wrap_Remote_get_noenumerate(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Remote instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRemote* self = info[0].As<Napi::External<FlatpakRemote>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Remote instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  gboolean result = flatpak_remote_get_noenumerate(self);

  return Napi::Boolean::New(env, result);
}

Napi::Value Wrap_Remote_get_prio(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Remote instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRemote* self = info[0].As<Napi::External<FlatpakRemote>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Remote instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  int result = flatpak_remote_get_prio(self);

  return Napi::Number::New(env, result);
}

Napi::Value Wrap_Remote_get_remote_type(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Remote instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRemote* self = info[0].As<Napi::External<FlatpakRemote>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Remote instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  FlatpakRemoteType result = flatpak_remote_get_remote_type(self);

  return Napi::Number::New(env, static_cast<int32_t>(result));
}

Napi::Value Wrap_Remote_get_title(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Remote instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRemote* self = info[0].As<Napi::External<FlatpakRemote>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Remote instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  char* result = flatpak_remote_get_title(self);

  Napi::String js_result = Napi::String::New(env, result ? result : "");
  g_free(result);
  return js_result;
}

Napi::Value Wrap_Remote_get_url(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Remote instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRemote* self = info[0].As<Napi::External<FlatpakRemote>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Remote instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  char* result = flatpak_remote_get_url(self);

  Napi::String js_result = Napi::String::New(env, result ? result : "");
  g_free(result);
  return js_result;
}

Napi::Value Wrap_Remote_set_collection_id(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Remote instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRemote* self = info[0].As<Napi::External<FlatpakRemote>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Remote instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  const char* collection_id = NULL;
  if (info.Length() > 1 && !info[1].IsNull() && !info[1].IsUndefined()) {
    if (!info[1].IsString()) {
      Napi::TypeError::New(env, "Expected string or null for parameter 'collection_id'").ThrowAsJavaScriptException();
      return env.Null();
    }
    std::string collection_id_str = info[1].As<Napi::String>().Utf8Value();
    collection_id = collection_id_str.c_str();
  }

  flatpak_remote_set_collection_id(self, collection_id);

  return env.Undefined();
}

Napi::Value Wrap_Remote_set_comment(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Remote instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRemote* self = info[0].As<Napi::External<FlatpakRemote>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Remote instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsString()) {
    Napi::TypeError::New(env, "Expected string for parameter 'comment'").ThrowAsJavaScriptException();
    return env.Null();
  }
  std::string comment_str = info[1].As<Napi::String>().Utf8Value();
  const char* comment = comment_str.c_str();

  flatpak_remote_set_comment(self, comment);

  return env.Undefined();
}

Napi::Value Wrap_Remote_set_default_branch(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Remote instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRemote* self = info[0].As<Napi::External<FlatpakRemote>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Remote instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsString()) {
    Napi::TypeError::New(env, "Expected string for parameter 'default_branch'").ThrowAsJavaScriptException();
    return env.Null();
  }
  std::string default_branch_str = info[1].As<Napi::String>().Utf8Value();
  const char* default_branch = default_branch_str.c_str();

  flatpak_remote_set_default_branch(self, default_branch);

  return env.Undefined();
}

Napi::Value Wrap_Remote_set_description(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Remote instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRemote* self = info[0].As<Napi::External<FlatpakRemote>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Remote instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsString()) {
    Napi::TypeError::New(env, "Expected string for parameter 'description'").ThrowAsJavaScriptException();
    return env.Null();
  }
  std::string description_str = info[1].As<Napi::String>().Utf8Value();
  const char* description = description_str.c_str();

  flatpak_remote_set_description(self, description);

  return env.Undefined();
}

Napi::Value Wrap_Remote_set_disabled(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Remote instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRemote* self = info[0].As<Napi::External<FlatpakRemote>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Remote instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsBoolean()) {
    Napi::TypeError::New(env, "Expected boolean for parameter 'disabled'").ThrowAsJavaScriptException();
    return env.Null();
  }
  gboolean disabled = info[1].As<Napi::Boolean>().Value();

  flatpak_remote_set_disabled(self, disabled);

  return env.Undefined();
}

Napi::Value Wrap_Remote_set_filter(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Remote instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRemote* self = info[0].As<Napi::External<FlatpakRemote>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Remote instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsString()) {
    Napi::TypeError::New(env, "Expected string for parameter 'filter_path'").ThrowAsJavaScriptException();
    return env.Null();
  }
  std::string filter_path_str = info[1].As<Napi::String>().Utf8Value();
  const char* filter_path = filter_path_str.c_str();

  flatpak_remote_set_filter(self, filter_path);

  return env.Undefined();
}

Napi::Value Wrap_Remote_set_gpg_key(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Remote instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRemote* self = info[0].As<Napi::External<FlatpakRemote>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Remote instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsExternal()) {
    Napi::TypeError::New(env, "Expected external object for parameter 'gpg_key'").ThrowAsJavaScriptException();
    return env.Null();
  }
  GBytes* gpg_key = info[1].As<Napi::External<GBytes>>().Data();

  flatpak_remote_set_gpg_key(self, gpg_key);

  return env.Undefined();
}

Napi::Value Wrap_Remote_set_gpg_verify(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Remote instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRemote* self = info[0].As<Napi::External<FlatpakRemote>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Remote instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsBoolean()) {
    Napi::TypeError::New(env, "Expected boolean for parameter 'gpg_verify'").ThrowAsJavaScriptException();
    return env.Null();
  }
  gboolean gpg_verify = info[1].As<Napi::Boolean>().Value();

  flatpak_remote_set_gpg_verify(self, gpg_verify);

  return env.Undefined();
}

Napi::Value Wrap_Remote_set_homepage(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Remote instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRemote* self = info[0].As<Napi::External<FlatpakRemote>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Remote instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsString()) {
    Napi::TypeError::New(env, "Expected string for parameter 'homepage'").ThrowAsJavaScriptException();
    return env.Null();
  }
  std::string homepage_str = info[1].As<Napi::String>().Utf8Value();
  const char* homepage = homepage_str.c_str();

  flatpak_remote_set_homepage(self, homepage);

  return env.Undefined();
}

Napi::Value Wrap_Remote_set_icon(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Remote instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRemote* self = info[0].As<Napi::External<FlatpakRemote>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Remote instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsString()) {
    Napi::TypeError::New(env, "Expected string for parameter 'icon'").ThrowAsJavaScriptException();
    return env.Null();
  }
  std::string icon_str = info[1].As<Napi::String>().Utf8Value();
  const char* icon = icon_str.c_str();

  flatpak_remote_set_icon(self, icon);

  return env.Undefined();
}

Napi::Value Wrap_Remote_set_main_ref(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Remote instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRemote* self = info[0].As<Napi::External<FlatpakRemote>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Remote instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsString()) {
    Napi::TypeError::New(env, "Expected string for parameter 'main_ref'").ThrowAsJavaScriptException();
    return env.Null();
  }
  std::string main_ref_str = info[1].As<Napi::String>().Utf8Value();
  const char* main_ref = main_ref_str.c_str();

  flatpak_remote_set_main_ref(self, main_ref);

  return env.Undefined();
}

Napi::Value Wrap_Remote_set_nodeps(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Remote instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRemote* self = info[0].As<Napi::External<FlatpakRemote>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Remote instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsBoolean()) {
    Napi::TypeError::New(env, "Expected boolean for parameter 'nodeps'").ThrowAsJavaScriptException();
    return env.Null();
  }
  gboolean nodeps = info[1].As<Napi::Boolean>().Value();

  flatpak_remote_set_nodeps(self, nodeps);

  return env.Undefined();
}

Napi::Value Wrap_Remote_set_noenumerate(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Remote instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRemote* self = info[0].As<Napi::External<FlatpakRemote>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Remote instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsBoolean()) {
    Napi::TypeError::New(env, "Expected boolean for parameter 'noenumerate'").ThrowAsJavaScriptException();
    return env.Null();
  }
  gboolean noenumerate = info[1].As<Napi::Boolean>().Value();

  flatpak_remote_set_noenumerate(self, noenumerate);

  return env.Undefined();
}

Napi::Value Wrap_Remote_set_prio(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Remote instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRemote* self = info[0].As<Napi::External<FlatpakRemote>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Remote instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsNumber()) {
    Napi::TypeError::New(env, "Expected number for parameter 'prio'").ThrowAsJavaScriptException();
    return env.Null();
  }
  int prio = info[1].As<Napi::Number>().Int32Value();

  flatpak_remote_set_prio(self, prio);

  return env.Undefined();
}

Napi::Value Wrap_Remote_set_title(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Remote instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRemote* self = info[0].As<Napi::External<FlatpakRemote>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Remote instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsString()) {
    Napi::TypeError::New(env, "Expected string for parameter 'title'").ThrowAsJavaScriptException();
    return env.Null();
  }
  std::string title_str = info[1].As<Napi::String>().Utf8Value();
  const char* title = title_str.c_str();

  flatpak_remote_set_title(self, title);

  return env.Undefined();
}

Napi::Value Wrap_Remote_set_url(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Remote instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRemote* self = info[0].As<Napi::External<FlatpakRemote>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Remote instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsString()) {
    Napi::TypeError::New(env, "Expected string for parameter 'url'").ThrowAsJavaScriptException();
    return env.Null();
  }
  std::string url_str = info[1].As<Napi::String>().Utf8Value();
  const char* url = url_str.c_str();

  flatpak_remote_set_url(self, url);

  return env.Undefined();
}

Napi::Value Wrap_RemoteRef_get_download_size(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected RemoteRef instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRemoteRef* self = info[0].As<Napi::External<FlatpakRemoteRef>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid RemoteRef instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  guint64 result = flatpak_remote_ref_get_download_size(self);

  return Napi::Number::New(env, result);
}

Napi::Value Wrap_RemoteRef_get_eol(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected RemoteRef instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRemoteRef* self = info[0].As<Napi::External<FlatpakRemoteRef>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid RemoteRef instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  const char* result = flatpak_remote_ref_get_eol(self);

  return Napi::String::New(env, result ? result : "");
}

Napi::Value Wrap_RemoteRef_get_eol_rebase(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected RemoteRef instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRemoteRef* self = info[0].As<Napi::External<FlatpakRemoteRef>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid RemoteRef instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  const char* result = flatpak_remote_ref_get_eol_rebase(self);

  return Napi::String::New(env, result ? result : "");
}

Napi::Value Wrap_RemoteRef_get_installed_size(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected RemoteRef instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRemoteRef* self = info[0].As<Napi::External<FlatpakRemoteRef>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid RemoteRef instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  guint64 result = flatpak_remote_ref_get_installed_size(self);

  return Napi::Number::New(env, result);
}

Napi::Value Wrap_RemoteRef_get_metadata(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected RemoteRef instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRemoteRef* self = info[0].As<Napi::External<FlatpakRemoteRef>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid RemoteRef instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  GBytes* result = flatpak_remote_ref_get_metadata(self);

  // Return GObject of type GLib.Bytes
  if (!result) {
    return env.Null();
  }
  // Increment reference count for GObject
  if (G_IS_OBJECT(result)) {
    g_object_ref(result);
    // Create external with finalizer
    return Napi::External<void>::New(env, result,
      [](Napi::Env env, void* obj) {
        if (obj && G_IS_OBJECT(obj)) {
          g_object_unref(static_cast<GObject*>(obj));
        }
      });
  } else {
    // Not a GObject, just pass as external
    return Napi::External<void>::New(env, result);
  }
}

Napi::Value Wrap_RemoteRef_get_remote_name(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected RemoteRef instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakRemoteRef* self = info[0].As<Napi::External<FlatpakRemoteRef>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid RemoteRef instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  const char* result = flatpak_remote_ref_get_remote_name(self);

  return Napi::String::New(env, result ? result : "");
}

Napi::Value Wrap_Transaction_new_for_installation(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() <= 0 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected external object for parameter 'installation'").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstallation* installation = info[0].As<Napi::External<FlatpakInstallation>>().Data();

  GCancellable* cancellable = NULL;
  if (info.Length() > 1 && !info[1].IsNull() && !info[1].IsUndefined()) {
    if (!info[1].IsExternal()) {
      Napi::TypeError::New(env, "Expected external object or null for parameter 'cancellable'").ThrowAsJavaScriptException();
      return env.Null();
    }
    cancellable = info[1].As<Napi::External<GCancellable>>().Data();
  }

  GError* error = NULL;
  FlatpakTransaction* result = flatpak_transaction_new_for_installation(installation, cancellable, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  // Return GObject of type Transaction
  if (!result) {
    return env.Null();
  }
  // Increment reference count for GObject
  if (G_IS_OBJECT(result)) {
    g_object_ref(result);
    // Create external with finalizer
    return Napi::External<void>::New(env, result,
      [](Napi::Env env, void* obj) {
        if (obj && G_IS_OBJECT(obj)) {
          g_object_unref(static_cast<GObject*>(obj));
        }
      });
  } else {
    // Not a GObject, just pass as external
    return Napi::External<void>::New(env, result);
  }
}

Napi::Value Wrap_Transaction_abort_webflow(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Transaction instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransaction* self = info[0].As<Napi::External<FlatpakTransaction>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Transaction instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsNumber()) {
    Napi::TypeError::New(env, "Expected number for parameter 'id'").ThrowAsJavaScriptException();
    return env.Null();
  }
  guint id = info[1].As<Napi::Number>().Int32Value();

  flatpak_transaction_abort_webflow(self, id);

  return env.Undefined();
}

Napi::Value Wrap_Transaction_add_default_dependency_sources(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Transaction instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransaction* self = info[0].As<Napi::External<FlatpakTransaction>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Transaction instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  flatpak_transaction_add_default_dependency_sources(self);

  return env.Undefined();
}

Napi::Value Wrap_Transaction_add_dependency_source(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Transaction instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransaction* self = info[0].As<Napi::External<FlatpakTransaction>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Transaction instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsExternal()) {
    Napi::TypeError::New(env, "Expected external object for parameter 'installation'").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakInstallation* installation = info[1].As<Napi::External<FlatpakInstallation>>().Data();

  flatpak_transaction_add_dependency_source(self, installation);

  return env.Undefined();
}

Napi::Value Wrap_Transaction_add_install_bundle(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Transaction instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransaction* self = info[0].As<Napi::External<FlatpakTransaction>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Transaction instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsExternal()) {
    Napi::TypeError::New(env, "Expected external object for parameter 'file'").ThrowAsJavaScriptException();
    return env.Null();
  }
  GFile* file = info[1].As<Napi::External<GFile>>().Data();

  GBytes* gpg_data = NULL;
  if (info.Length() > 2 && !info[2].IsNull() && !info[2].IsUndefined()) {
    if (!info[2].IsExternal()) {
      Napi::TypeError::New(env, "Expected external object or null for parameter 'gpg_data'").ThrowAsJavaScriptException();
      return env.Null();
    }
    gpg_data = info[2].As<Napi::External<GBytes>>().Data();
  }

  GError* error = NULL;
  gboolean result = flatpak_transaction_add_install_bundle(self, file, gpg_data, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  return Napi::Boolean::New(env, result);
}

Napi::Value Wrap_Transaction_add_install_flatpakref(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Transaction instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransaction* self = info[0].As<Napi::External<FlatpakTransaction>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Transaction instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsExternal()) {
    Napi::TypeError::New(env, "Expected external object for parameter 'flatpakref_data'").ThrowAsJavaScriptException();
    return env.Null();
  }
  GBytes* flatpakref_data = info[1].As<Napi::External<GBytes>>().Data();

  GError* error = NULL;
  gboolean result = flatpak_transaction_add_install_flatpakref(self, flatpakref_data, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  return Napi::Boolean::New(env, result);
}

Napi::Value Wrap_Transaction_add_sideload_repo(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Transaction instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransaction* self = info[0].As<Napi::External<FlatpakTransaction>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Transaction instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsString()) {
    Napi::TypeError::New(env, "Expected string for parameter 'path'").ThrowAsJavaScriptException();
    return env.Null();
  }
  std::string path_str = info[1].As<Napi::String>().Utf8Value();
  const char* path = path_str.c_str();

  flatpak_transaction_add_sideload_repo(self, path);

  return env.Undefined();
}

Napi::Value Wrap_Transaction_add_uninstall(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Transaction instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransaction* self = info[0].As<Napi::External<FlatpakTransaction>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Transaction instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsString()) {
    Napi::TypeError::New(env, "Expected string for parameter 'ref'").ThrowAsJavaScriptException();
    return env.Null();
  }
  std::string ref_str = info[1].As<Napi::String>().Utf8Value();
  const char* ref = ref_str.c_str();

  GError* error = NULL;
  gboolean result = flatpak_transaction_add_uninstall(self, ref, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  return Napi::Boolean::New(env, result);
}

Napi::Value Wrap_Transaction_complete_basic_auth(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Transaction instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransaction* self = info[0].As<Napi::External<FlatpakTransaction>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Transaction instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsNumber()) {
    Napi::TypeError::New(env, "Expected number for parameter 'id'").ThrowAsJavaScriptException();
    return env.Null();
  }
  guint id = info[1].As<Napi::Number>().Int32Value();

  if (info.Length() <= 2 || !info[2].IsString()) {
    Napi::TypeError::New(env, "Expected string for parameter 'user'").ThrowAsJavaScriptException();
    return env.Null();
  }
  std::string user_str = info[2].As<Napi::String>().Utf8Value();
  const char* user = user_str.c_str();

  if (info.Length() <= 3 || !info[3].IsString()) {
    Napi::TypeError::New(env, "Expected string for parameter 'password'").ThrowAsJavaScriptException();
    return env.Null();
  }
  std::string password_str = info[3].As<Napi::String>().Utf8Value();
  const char* password = password_str.c_str();

  if (info.Length() <= 4 || !info[4].IsExternal()) {
    Napi::TypeError::New(env, "Expected external object for parameter 'options'").ThrowAsJavaScriptException();
    return env.Null();
  }
  GVariant* options = info[4].As<Napi::External<GVariant>>().Data();

  flatpak_transaction_complete_basic_auth(self, id, user, password, options);

  return env.Undefined();
}

Napi::Value Wrap_Transaction_get_auto_install_debug(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Transaction instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransaction* self = info[0].As<Napi::External<FlatpakTransaction>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Transaction instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  gboolean result = flatpak_transaction_get_auto_install_debug(self);

  return Napi::Boolean::New(env, result);
}

Napi::Value Wrap_Transaction_get_auto_install_sdk(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Transaction instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransaction* self = info[0].As<Napi::External<FlatpakTransaction>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Transaction instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  gboolean result = flatpak_transaction_get_auto_install_sdk(self);

  return Napi::Boolean::New(env, result);
}

Napi::Value Wrap_Transaction_get_current_operation(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Transaction instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransaction* self = info[0].As<Napi::External<FlatpakTransaction>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Transaction instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  FlatpakTransactionOperation* result = flatpak_transaction_get_current_operation(self);

  // Return GObject of type TransactionOperation
  if (!result) {
    return env.Null();
  }
  // Increment reference count for GObject
  if (G_IS_OBJECT(result)) {
    g_object_ref(result);
    // Create external with finalizer
    return Napi::External<void>::New(env, result,
      [](Napi::Env env, void* obj) {
        if (obj && G_IS_OBJECT(obj)) {
          g_object_unref(static_cast<GObject*>(obj));
        }
      });
  } else {
    // Not a GObject, just pass as external
    return Napi::External<void>::New(env, result);
  }
}

Napi::Value Wrap_Transaction_get_include_unused_uninstall_ops(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Transaction instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransaction* self = info[0].As<Napi::External<FlatpakTransaction>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Transaction instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  gboolean result = flatpak_transaction_get_include_unused_uninstall_ops(self);

  return Napi::Boolean::New(env, result);
}

Napi::Value Wrap_Transaction_get_installation(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Transaction instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransaction* self = info[0].As<Napi::External<FlatpakTransaction>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Transaction instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  FlatpakInstallation* result = flatpak_transaction_get_installation(self);

  // Return GObject of type Installation
  if (!result) {
    return env.Null();
  }
  // Increment reference count for GObject
  if (G_IS_OBJECT(result)) {
    g_object_ref(result);
    // Create external with finalizer
    return Napi::External<void>::New(env, result,
      [](Napi::Env env, void* obj) {
        if (obj && G_IS_OBJECT(obj)) {
          g_object_unref(static_cast<GObject*>(obj));
        }
      });
  } else {
    // Not a GObject, just pass as external
    return Napi::External<void>::New(env, result);
  }
}

Napi::Value Wrap_Transaction_get_no_deploy(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Transaction instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransaction* self = info[0].As<Napi::External<FlatpakTransaction>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Transaction instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  gboolean result = flatpak_transaction_get_no_deploy(self);

  return Napi::Boolean::New(env, result);
}

Napi::Value Wrap_Transaction_get_no_interaction(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Transaction instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransaction* self = info[0].As<Napi::External<FlatpakTransaction>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Transaction instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  gboolean result = flatpak_transaction_get_no_interaction(self);

  return Napi::Boolean::New(env, result);
}

Napi::Value Wrap_Transaction_get_no_pull(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Transaction instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransaction* self = info[0].As<Napi::External<FlatpakTransaction>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Transaction instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  gboolean result = flatpak_transaction_get_no_pull(self);

  return Napi::Boolean::New(env, result);
}

Napi::Value Wrap_Transaction_get_operation_for_ref(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Transaction instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransaction* self = info[0].As<Napi::External<FlatpakTransaction>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Transaction instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  const char* remote = NULL;
  if (info.Length() > 1 && !info[1].IsNull() && !info[1].IsUndefined()) {
    if (!info[1].IsString()) {
      Napi::TypeError::New(env, "Expected string or null for parameter 'remote'").ThrowAsJavaScriptException();
      return env.Null();
    }
    std::string remote_str = info[1].As<Napi::String>().Utf8Value();
    remote = remote_str.c_str();
  }

  if (info.Length() <= 2 || !info[2].IsString()) {
    Napi::TypeError::New(env, "Expected string for parameter 'ref'").ThrowAsJavaScriptException();
    return env.Null();
  }
  std::string ref_str = info[2].As<Napi::String>().Utf8Value();
  const char* ref = ref_str.c_str();

  GError* error = NULL;
  FlatpakTransactionOperation* result = flatpak_transaction_get_operation_for_ref(self, remote, ref, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  // Return GObject of type TransactionOperation
  if (!result) {
    return env.Null();
  }
  // Increment reference count for GObject
  if (G_IS_OBJECT(result)) {
    g_object_ref(result);
    // Create external with finalizer
    return Napi::External<void>::New(env, result,
      [](Napi::Env env, void* obj) {
        if (obj && G_IS_OBJECT(obj)) {
          g_object_unref(static_cast<GObject*>(obj));
        }
      });
  } else {
    // Not a GObject, just pass as external
    return Napi::External<void>::New(env, result);
  }
}

Napi::Value Wrap_Transaction_get_operations(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Transaction instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransaction* self = info[0].As<Napi::External<FlatpakTransaction>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Transaction instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  GList* result = flatpak_transaction_get_operations(self);

  // Return GObject of type GLib.List
  if (!result) {
    return env.Null();
  }
  // Increment reference count for GObject
  if (G_IS_OBJECT(result)) {
    g_object_ref(result);
    // Create external with finalizer
    return Napi::External<void>::New(env, result,
      [](Napi::Env env, void* obj) {
        if (obj && G_IS_OBJECT(obj)) {
          g_object_unref(static_cast<GObject*>(obj));
        }
      });
  } else {
    // Not a GObject, just pass as external
    return Napi::External<void>::New(env, result);
  }
}

Napi::Value Wrap_Transaction_get_parent_window(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Transaction instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransaction* self = info[0].As<Napi::External<FlatpakTransaction>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Transaction instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  const char* result = flatpak_transaction_get_parent_window(self);

  return Napi::String::New(env, result ? result : "");
}

Napi::Value Wrap_Transaction_is_empty(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Transaction instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransaction* self = info[0].As<Napi::External<FlatpakTransaction>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Transaction instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  gboolean result = flatpak_transaction_is_empty(self);

  return Napi::Boolean::New(env, result);
}

Napi::Value Wrap_Transaction_run(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Transaction instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransaction* self = info[0].As<Napi::External<FlatpakTransaction>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Transaction instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  GCancellable* cancellable = NULL;
  if (info.Length() > 1 && !info[1].IsNull() && !info[1].IsUndefined()) {
    if (!info[1].IsExternal()) {
      Napi::TypeError::New(env, "Expected external object or null for parameter 'cancellable'").ThrowAsJavaScriptException();
      return env.Null();
    }
    cancellable = info[1].As<Napi::External<GCancellable>>().Data();
  }

  GError* error = NULL;
  gboolean result = flatpak_transaction_run(self, cancellable, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  return Napi::Boolean::New(env, result);
}

Napi::Value Wrap_Transaction_set_auto_install_debug(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Transaction instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransaction* self = info[0].As<Napi::External<FlatpakTransaction>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Transaction instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsBoolean()) {
    Napi::TypeError::New(env, "Expected boolean for parameter 'auto_install_debug'").ThrowAsJavaScriptException();
    return env.Null();
  }
  gboolean auto_install_debug = info[1].As<Napi::Boolean>().Value();

  flatpak_transaction_set_auto_install_debug(self, auto_install_debug);

  return env.Undefined();
}

Napi::Value Wrap_Transaction_set_auto_install_sdk(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Transaction instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransaction* self = info[0].As<Napi::External<FlatpakTransaction>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Transaction instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsBoolean()) {
    Napi::TypeError::New(env, "Expected boolean for parameter 'auto_install_sdk'").ThrowAsJavaScriptException();
    return env.Null();
  }
  gboolean auto_install_sdk = info[1].As<Napi::Boolean>().Value();

  flatpak_transaction_set_auto_install_sdk(self, auto_install_sdk);

  return env.Undefined();
}

Napi::Value Wrap_Transaction_set_default_arch(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Transaction instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransaction* self = info[0].As<Napi::External<FlatpakTransaction>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Transaction instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsString()) {
    Napi::TypeError::New(env, "Expected string for parameter 'arch'").ThrowAsJavaScriptException();
    return env.Null();
  }
  std::string arch_str = info[1].As<Napi::String>().Utf8Value();
  const char* arch = arch_str.c_str();

  flatpak_transaction_set_default_arch(self, arch);

  return env.Undefined();
}

Napi::Value Wrap_Transaction_set_disable_auto_pin(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Transaction instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransaction* self = info[0].As<Napi::External<FlatpakTransaction>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Transaction instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsBoolean()) {
    Napi::TypeError::New(env, "Expected boolean for parameter 'disable_pin'").ThrowAsJavaScriptException();
    return env.Null();
  }
  gboolean disable_pin = info[1].As<Napi::Boolean>().Value();

  flatpak_transaction_set_disable_auto_pin(self, disable_pin);

  return env.Undefined();
}

Napi::Value Wrap_Transaction_set_disable_dependencies(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Transaction instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransaction* self = info[0].As<Napi::External<FlatpakTransaction>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Transaction instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsBoolean()) {
    Napi::TypeError::New(env, "Expected boolean for parameter 'disable_dependencies'").ThrowAsJavaScriptException();
    return env.Null();
  }
  gboolean disable_dependencies = info[1].As<Napi::Boolean>().Value();

  flatpak_transaction_set_disable_dependencies(self, disable_dependencies);

  return env.Undefined();
}

Napi::Value Wrap_Transaction_set_disable_prune(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Transaction instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransaction* self = info[0].As<Napi::External<FlatpakTransaction>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Transaction instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsBoolean()) {
    Napi::TypeError::New(env, "Expected boolean for parameter 'disable_prune'").ThrowAsJavaScriptException();
    return env.Null();
  }
  gboolean disable_prune = info[1].As<Napi::Boolean>().Value();

  flatpak_transaction_set_disable_prune(self, disable_prune);

  return env.Undefined();
}

Napi::Value Wrap_Transaction_set_disable_related(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Transaction instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransaction* self = info[0].As<Napi::External<FlatpakTransaction>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Transaction instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsBoolean()) {
    Napi::TypeError::New(env, "Expected boolean for parameter 'disable_related'").ThrowAsJavaScriptException();
    return env.Null();
  }
  gboolean disable_related = info[1].As<Napi::Boolean>().Value();

  flatpak_transaction_set_disable_related(self, disable_related);

  return env.Undefined();
}

Napi::Value Wrap_Transaction_set_disable_static_deltas(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Transaction instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransaction* self = info[0].As<Napi::External<FlatpakTransaction>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Transaction instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsBoolean()) {
    Napi::TypeError::New(env, "Expected boolean for parameter 'disable_static_deltas'").ThrowAsJavaScriptException();
    return env.Null();
  }
  gboolean disable_static_deltas = info[1].As<Napi::Boolean>().Value();

  flatpak_transaction_set_disable_static_deltas(self, disable_static_deltas);

  return env.Undefined();
}

Napi::Value Wrap_Transaction_set_force_uninstall(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Transaction instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransaction* self = info[0].As<Napi::External<FlatpakTransaction>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Transaction instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsBoolean()) {
    Napi::TypeError::New(env, "Expected boolean for parameter 'force_uninstall'").ThrowAsJavaScriptException();
    return env.Null();
  }
  gboolean force_uninstall = info[1].As<Napi::Boolean>().Value();

  flatpak_transaction_set_force_uninstall(self, force_uninstall);

  return env.Undefined();
}

Napi::Value Wrap_Transaction_set_include_unused_uninstall_ops(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Transaction instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransaction* self = info[0].As<Napi::External<FlatpakTransaction>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Transaction instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsBoolean()) {
    Napi::TypeError::New(env, "Expected boolean for parameter 'include_unused_uninstall_ops'").ThrowAsJavaScriptException();
    return env.Null();
  }
  gboolean include_unused_uninstall_ops = info[1].As<Napi::Boolean>().Value();

  flatpak_transaction_set_include_unused_uninstall_ops(self, include_unused_uninstall_ops);

  return env.Undefined();
}

Napi::Value Wrap_Transaction_set_no_deploy(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Transaction instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransaction* self = info[0].As<Napi::External<FlatpakTransaction>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Transaction instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsBoolean()) {
    Napi::TypeError::New(env, "Expected boolean for parameter 'no_deploy'").ThrowAsJavaScriptException();
    return env.Null();
  }
  gboolean no_deploy = info[1].As<Napi::Boolean>().Value();

  flatpak_transaction_set_no_deploy(self, no_deploy);

  return env.Undefined();
}

Napi::Value Wrap_Transaction_set_no_interaction(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Transaction instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransaction* self = info[0].As<Napi::External<FlatpakTransaction>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Transaction instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsBoolean()) {
    Napi::TypeError::New(env, "Expected boolean for parameter 'no_interaction'").ThrowAsJavaScriptException();
    return env.Null();
  }
  gboolean no_interaction = info[1].As<Napi::Boolean>().Value();

  flatpak_transaction_set_no_interaction(self, no_interaction);

  return env.Undefined();
}

Napi::Value Wrap_Transaction_set_no_pull(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Transaction instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransaction* self = info[0].As<Napi::External<FlatpakTransaction>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Transaction instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsBoolean()) {
    Napi::TypeError::New(env, "Expected boolean for parameter 'no_pull'").ThrowAsJavaScriptException();
    return env.Null();
  }
  gboolean no_pull = info[1].As<Napi::Boolean>().Value();

  flatpak_transaction_set_no_pull(self, no_pull);

  return env.Undefined();
}

Napi::Value Wrap_Transaction_set_parent_window(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Transaction instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransaction* self = info[0].As<Napi::External<FlatpakTransaction>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Transaction instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsString()) {
    Napi::TypeError::New(env, "Expected string for parameter 'parent_window'").ThrowAsJavaScriptException();
    return env.Null();
  }
  std::string parent_window_str = info[1].As<Napi::String>().Utf8Value();
  const char* parent_window = parent_window_str.c_str();

  flatpak_transaction_set_parent_window(self, parent_window);

  return env.Undefined();
}

Napi::Value Wrap_Transaction_set_reinstall(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected Transaction instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransaction* self = info[0].As<Napi::External<FlatpakTransaction>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid Transaction instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsBoolean()) {
    Napi::TypeError::New(env, "Expected boolean for parameter 'reinstall'").ThrowAsJavaScriptException();
    return env.Null();
  }
  gboolean reinstall = info[1].As<Napi::Boolean>().Value();

  flatpak_transaction_set_reinstall(self, reinstall);

  return env.Undefined();
}

Napi::Value Wrap_TransactionOperation_get_bundle_path(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected TransactionOperation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransactionOperation* self = info[0].As<Napi::External<FlatpakTransactionOperation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid TransactionOperation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  GFile* result = flatpak_transaction_operation_get_bundle_path(self);

  // Return GObject of type Gio.File
  if (!result) {
    return env.Null();
  }
  // Increment reference count for GObject
  if (G_IS_OBJECT(result)) {
    g_object_ref(result);
    // Create external with finalizer
    return Napi::External<void>::New(env, result,
      [](Napi::Env env, void* obj) {
        if (obj && G_IS_OBJECT(obj)) {
          g_object_unref(static_cast<GObject*>(obj));
        }
      });
  } else {
    // Not a GObject, just pass as external
    return Napi::External<void>::New(env, result);
  }
}

Napi::Value Wrap_TransactionOperation_get_commit(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected TransactionOperation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransactionOperation* self = info[0].As<Napi::External<FlatpakTransactionOperation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid TransactionOperation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  const char* result = flatpak_transaction_operation_get_commit(self);

  return Napi::String::New(env, result ? result : "");
}

Napi::Value Wrap_TransactionOperation_get_download_size(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected TransactionOperation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransactionOperation* self = info[0].As<Napi::External<FlatpakTransactionOperation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid TransactionOperation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  guint64 result = flatpak_transaction_operation_get_download_size(self);

  return Napi::Number::New(env, result);
}

Napi::Value Wrap_TransactionOperation_get_installed_size(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected TransactionOperation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransactionOperation* self = info[0].As<Napi::External<FlatpakTransactionOperation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid TransactionOperation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  guint64 result = flatpak_transaction_operation_get_installed_size(self);

  return Napi::Number::New(env, result);
}

Napi::Value Wrap_TransactionOperation_get_is_skipped(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected TransactionOperation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransactionOperation* self = info[0].As<Napi::External<FlatpakTransactionOperation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid TransactionOperation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  gboolean result = flatpak_transaction_operation_get_is_skipped(self);

  return Napi::Boolean::New(env, result);
}

Napi::Value Wrap_TransactionOperation_get_metadata(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected TransactionOperation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransactionOperation* self = info[0].As<Napi::External<FlatpakTransactionOperation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid TransactionOperation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  GKeyFile* result = flatpak_transaction_operation_get_metadata(self);

  // Return GObject of type GLib.KeyFile
  if (!result) {
    return env.Null();
  }
  // Increment reference count for GObject
  if (G_IS_OBJECT(result)) {
    g_object_ref(result);
    // Create external with finalizer
    return Napi::External<void>::New(env, result,
      [](Napi::Env env, void* obj) {
        if (obj && G_IS_OBJECT(obj)) {
          g_object_unref(static_cast<GObject*>(obj));
        }
      });
  } else {
    // Not a GObject, just pass as external
    return Napi::External<void>::New(env, result);
  }
}

Napi::Value Wrap_TransactionOperation_get_old_metadata(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected TransactionOperation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransactionOperation* self = info[0].As<Napi::External<FlatpakTransactionOperation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid TransactionOperation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  GKeyFile* result = flatpak_transaction_operation_get_old_metadata(self);

  // Return GObject of type GLib.KeyFile
  if (!result) {
    return env.Null();
  }
  // Increment reference count for GObject
  if (G_IS_OBJECT(result)) {
    g_object_ref(result);
    // Create external with finalizer
    return Napi::External<void>::New(env, result,
      [](Napi::Env env, void* obj) {
        if (obj && G_IS_OBJECT(obj)) {
          g_object_unref(static_cast<GObject*>(obj));
        }
      });
  } else {
    // Not a GObject, just pass as external
    return Napi::External<void>::New(env, result);
  }
}

Napi::Value Wrap_TransactionOperation_get_operation_type(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected TransactionOperation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransactionOperation* self = info[0].As<Napi::External<FlatpakTransactionOperation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid TransactionOperation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  FlatpakTransactionOperationType result = flatpak_transaction_operation_get_operation_type(self);

  return Napi::Number::New(env, static_cast<int32_t>(result));
}

Napi::Value Wrap_TransactionOperation_get_ref(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected TransactionOperation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransactionOperation* self = info[0].As<Napi::External<FlatpakTransactionOperation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid TransactionOperation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  const char* result = flatpak_transaction_operation_get_ref(self);

  return Napi::String::New(env, result ? result : "");
}

Napi::Value Wrap_TransactionOperation_get_related_to_ops(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected TransactionOperation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransactionOperation* self = info[0].As<Napi::External<FlatpakTransactionOperation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid TransactionOperation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  GPtrArray* result = flatpak_transaction_operation_get_related_to_ops(self);

  // Convert GPtrArray to JavaScript array
  Napi::Array js_array = Napi::Array::New(env);
  if (result) {
    GPtrArray* array = result;
    for (guint i = 0; i < array->len; i++) {
      gpointer item = g_ptr_array_index(array, i);
      if (!item) {
        js_array.Set(i, env.Null());
        continue;
      }
      FlatpakTransactionOperation* typed_item = static_cast<FlatpakTransactionOperation*>(item);
      if (!typed_item) {
        js_array.Set(i, env.Null());
        continue;
      }
      // Increment reference count for GObject
      if (G_IS_OBJECT(typed_item)) {
        g_object_ref(typed_item);
        // Create external with finalizer
        js_array.Set(i, Napi::External<FlatpakTransactionOperation>::New(env, typed_item,
          [](Napi::Env env, FlatpakTransactionOperation* obj) {
            if (obj && G_IS_OBJECT(obj)) {
              g_object_unref(obj);
            }
          }));
      } else {
        // Not a GObject, just pass as external
        js_array.Set(i, Napi::External<FlatpakTransactionOperation>::New(env, typed_item));
      }
    }
    // Unref the array but not the contained objects
  }
  return js_array;
}

Napi::Value Wrap_TransactionOperation_get_remote(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected TransactionOperation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransactionOperation* self = info[0].As<Napi::External<FlatpakTransactionOperation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid TransactionOperation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  const char* result = flatpak_transaction_operation_get_remote(self);

  return Napi::String::New(env, result ? result : "");
}

Napi::Value Wrap_TransactionOperation_get_requires_authentication(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected TransactionOperation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransactionOperation* self = info[0].As<Napi::External<FlatpakTransactionOperation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid TransactionOperation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  gboolean result = flatpak_transaction_operation_get_requires_authentication(self);

  return Napi::Boolean::New(env, result);
}

Napi::Value Wrap_TransactionOperation_get_subpaths(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected TransactionOperation instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransactionOperation* self = info[0].As<Napi::External<FlatpakTransactionOperation>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid TransactionOperation instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  const char* const* result = flatpak_transaction_operation_get_subpaths(self);

  // Convert string array (GLib.Strv) to JavaScript array
  Napi::Array js_array = Napi::Array::New(env);
  if (result) {
    int i = 0;
    while (result[i]) {
      js_array.Set(i, Napi::String::New(env, result[i]));
      i++;
    }
  }
  return js_array;
}

Napi::Value Wrap_TransactionProgress_get_bytes_transferred(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected TransactionProgress instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransactionProgress* self = info[0].As<Napi::External<FlatpakTransactionProgress>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid TransactionProgress instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  guint64 result = flatpak_transaction_progress_get_bytes_transferred(self);

  return Napi::Number::New(env, result);
}

Napi::Value Wrap_TransactionProgress_get_is_estimating(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected TransactionProgress instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransactionProgress* self = info[0].As<Napi::External<FlatpakTransactionProgress>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid TransactionProgress instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  gboolean result = flatpak_transaction_progress_get_is_estimating(self);

  return Napi::Boolean::New(env, result);
}

Napi::Value Wrap_TransactionProgress_get_progress(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected TransactionProgress instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransactionProgress* self = info[0].As<Napi::External<FlatpakTransactionProgress>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid TransactionProgress instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  int result = flatpak_transaction_progress_get_progress(self);

  return Napi::Number::New(env, result);
}

Napi::Value Wrap_TransactionProgress_get_start_time(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected TransactionProgress instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransactionProgress* self = info[0].As<Napi::External<FlatpakTransactionProgress>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid TransactionProgress instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  guint64 result = flatpak_transaction_progress_get_start_time(self);

  return Napi::Number::New(env, result);
}

Napi::Value Wrap_TransactionProgress_get_status(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected TransactionProgress instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransactionProgress* self = info[0].As<Napi::External<FlatpakTransactionProgress>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid TransactionProgress instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  char* result = flatpak_transaction_progress_get_status(self);

  Napi::String js_result = Napi::String::New(env, result ? result : "");
  g_free(result);
  return js_result;
}

Napi::Value Wrap_TransactionProgress_set_update_frequency(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() < 1 || !info[0].IsExternal()) {
    Napi::TypeError::New(env, "Expected TransactionProgress instance").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransactionProgress* self = info[0].As<Napi::External<FlatpakTransactionProgress>>().Data();

  if (!self) {
    Napi::Error::New(env, "Invalid TransactionProgress instance (null pointer)").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (info.Length() <= 1 || !info[1].IsNumber()) {
    Napi::TypeError::New(env, "Expected number for parameter 'update_interval'").ThrowAsJavaScriptException();
    return env.Null();
  }
  guint update_interval = info[1].As<Napi::Number>().Int32Value();

  flatpak_transaction_progress_set_update_frequency(self, update_interval);

  return env.Undefined();
}

Napi::Value Wrap_flatpak_error_quark(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  GQuark result = flatpak_error_quark();

  return Napi::Number::New(env, result);
}

Napi::Value Wrap_flatpak_instance_get_all(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  GPtrArray* result = flatpak_instance_get_all();

  // Convert GPtrArray to JavaScript array
  Napi::Array js_array = Napi::Array::New(env);
  if (result) {
    GPtrArray* array = result;
    for (guint i = 0; i < array->len; i++) {
      gpointer item = g_ptr_array_index(array, i);
      if (!item) {
        js_array.Set(i, env.Null());
        continue;
      }
      FlatpakInstance* typed_item = static_cast<FlatpakInstance*>(item);
      if (!typed_item) {
        js_array.Set(i, env.Null());
        continue;
      }
      // Increment reference count for GObject
      if (G_IS_OBJECT(typed_item)) {
        g_object_ref(typed_item);
        // Create external with finalizer
        js_array.Set(i, Napi::External<FlatpakInstance>::New(env, typed_item,
          [](Napi::Env env, FlatpakInstance* obj) {
            if (obj && G_IS_OBJECT(obj)) {
              g_object_unref(obj);
            }
          }));
      } else {
        // Not a GObject, just pass as external
        js_array.Set(i, Napi::External<FlatpakInstance>::New(env, typed_item));
      }
    }
    // Unref the array but not the contained objects
    g_ptr_array_unref(result);
  }
  return js_array;
}

Napi::Value Wrap_flatpak_portal_error_quark(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  GQuark result = flatpak_portal_error_quark();

  return Napi::Number::New(env, result);
}

Napi::Value Wrap_flatpak_ref_parse(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() <= 0 || !info[0].IsString()) {
    Napi::TypeError::New(env, "Expected string for parameter 'ref'").ThrowAsJavaScriptException();
    return env.Null();
  }
  std::string ref_str = info[0].As<Napi::String>().Utf8Value();
  const char* ref = ref_str.c_str();

  GError* error = NULL;
  FlatpakRef* result = flatpak_ref_parse(ref, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  // Return GObject of type Ref
  if (!result) {
    return env.Null();
  }
  // Increment reference count for GObject
  if (G_IS_OBJECT(result)) {
    g_object_ref(result);
    // Create external with finalizer
    return Napi::External<void>::New(env, result,
      [](Napi::Env env, void* obj) {
        if (obj && G_IS_OBJECT(obj)) {
          g_object_unref(static_cast<GObject*>(obj));
        }
      });
  } else {
    // Not a GObject, just pass as external
    return Napi::External<void>::New(env, result);
  }
}

Napi::Value Wrap_flatpak_transaction_operation_type_to_string(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  if (info.Length() <= 0 || !info[0].IsNumber()) {
    Napi::TypeError::New(env, "Expected number for enum parameter 'kind'").ThrowAsJavaScriptException();
    return env.Null();
  }
  FlatpakTransactionOperationType kind = static_cast<FlatpakTransactionOperationType>(info[0].As<Napi::Number>().Int32Value());

  const char* result = flatpak_transaction_operation_type_to_string(kind);

  return Napi::String::New(env, result ? result : "");
}

Napi::Value Wrap_flatpak_get_default_arch(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  const char* result = flatpak_get_default_arch();

  return Napi::String::New(env, result ? result : "");
}

Napi::Value Wrap_flatpak_get_supported_arches(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  const char* const* result = flatpak_get_supported_arches();

  // Convert string array (GLib.Strv) to JavaScript array
  Napi::Array js_array = Napi::Array::New(env);
  if (result) {
    int i = 0;
    while (result[i]) {
      js_array.Set(i, Napi::String::New(env, result[i]));
      i++;
    }
  }
  return js_array;
}

Napi::Value Wrap_flatpak_get_system_installations(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  GCancellable* cancellable = NULL;
  if (info.Length() > 0 && !info[0].IsNull() && !info[0].IsUndefined()) {
    if (!info[0].IsExternal()) {
      Napi::TypeError::New(env, "Expected external object or null for parameter 'cancellable'").ThrowAsJavaScriptException();
      return env.Null();
    }
    cancellable = info[0].As<Napi::External<GCancellable>>().Data();
  }

  GError* error = NULL;
  GPtrArray* result = flatpak_get_system_installations(cancellable, &error);

  if (error) {
    Napi::Error::New(env, error->message).ThrowAsJavaScriptException();
    g_error_free(error);
    return env.Null();
  }

  // Convert GPtrArray to JavaScript array
  Napi::Array js_array = Napi::Array::New(env);
  if (result) {
    GPtrArray* array = result;
    for (guint i = 0; i < array->len; i++) {
      gpointer item = g_ptr_array_index(array, i);
      if (!item) {
        js_array.Set(i, env.Null());
        continue;
      }
      FlatpakInstallation* typed_item = static_cast<FlatpakInstallation*>(item);
      if (!typed_item) {
        js_array.Set(i, env.Null());
        continue;
      }
      // Increment reference count for GObject
      if (G_IS_OBJECT(typed_item)) {
        g_object_ref(typed_item);
        // Create external with finalizer
        js_array.Set(i, Napi::External<FlatpakInstallation>::New(env, typed_item,
          [](Napi::Env env, FlatpakInstallation* obj) {
            if (obj && G_IS_OBJECT(obj)) {
              g_object_unref(obj);
            }
          }));
      } else {
        // Not a GObject, just pass as external
        js_array.Set(i, Napi::External<FlatpakInstallation>::New(env, typed_item));
      }
    }
    // Unref the array but not the contained objects
    g_ptr_array_unref(result);
  }
  return js_array;
}


Napi::Object Init(Napi::Env env, Napi::Object exports) {
  exports.Set("errorQuark", Napi::Function::New(env, Wrap_flatpak_error_quark));
  exports.Set("getAll", Napi::Function::New(env, Wrap_flatpak_instance_get_all));
  exports.Set("portalErrorQuark", Napi::Function::New(env, Wrap_flatpak_portal_error_quark));
  exports.Set("parse", Napi::Function::New(env, Wrap_flatpak_ref_parse));
  exports.Set("toString", Napi::Function::New(env, Wrap_flatpak_transaction_operation_type_to_string));
  exports.Set("getDefaultArch", Napi::Function::New(env, Wrap_flatpak_get_default_arch));
  exports.Set("getSupportedArches", Napi::Function::New(env, Wrap_flatpak_get_supported_arches));
  exports.Set("getSystemInstallations", Napi::Function::New(env, Wrap_flatpak_get_system_installations));
  // BundleRef class
  Napi::Object bundleref_class = Napi::Object::New(env);
  bundleref_class.Set("new", Napi::Function::New(env, Wrap_BundleRef_new));
  bundleref_class.Set("getAppstream", Napi::Function::New(env, Wrap_BundleRef_get_appstream));
  bundleref_class.Set("getFile", Napi::Function::New(env, Wrap_BundleRef_get_file));
  bundleref_class.Set("getIcon", Napi::Function::New(env, Wrap_BundleRef_get_icon));
  bundleref_class.Set("getInstalledSize", Napi::Function::New(env, Wrap_BundleRef_get_installed_size));
  bundleref_class.Set("getMetadata", Napi::Function::New(env, Wrap_BundleRef_get_metadata));
  bundleref_class.Set("getOrigin", Napi::Function::New(env, Wrap_BundleRef_get_origin));
  bundleref_class.Set("getRuntimeRepoUrl", Napi::Function::New(env, Wrap_BundleRef_get_runtime_repo_url));
  exports.Set("BundleRef", bundleref_class);
  // Installation class
  Napi::Object installation_class = Napi::Object::New(env);
  installation_class.Set("new", Napi::Function::New(env, Wrap_Installation_new_for_path));
  installation_class.Set("new", Napi::Function::New(env, Wrap_Installation_new_system));
  installation_class.Set("new", Napi::Function::New(env, Wrap_Installation_new_system_with_id));
  installation_class.Set("new", Napi::Function::New(env, Wrap_Installation_new_user));
  installation_class.Set("addRemote", Napi::Function::New(env, Wrap_Installation_add_remote));
  installation_class.Set("cleanupLocalRefsSync", Napi::Function::New(env, Wrap_Installation_cleanup_local_refs_sync));
  installation_class.Set("createMonitor", Napi::Function::New(env, Wrap_Installation_create_monitor));
  installation_class.Set("dropCaches", Napi::Function::New(env, Wrap_Installation_drop_caches));
  installation_class.Set("fetchRemoteMetadataSync", Napi::Function::New(env, Wrap_Installation_fetch_remote_metadata_sync));
  installation_class.Set("fetchRemoteRefSync", Napi::Function::New(env, Wrap_Installation_fetch_remote_ref_sync));
  installation_class.Set("fetchRemoteRefSyncFull", Napi::Function::New(env, Wrap_Installation_fetch_remote_ref_sync_full));
  installation_class.Set("fetchRemoteSizeSync", Napi::Function::New(env, Wrap_Installation_fetch_remote_size_sync));
  installation_class.Set("getConfig", Napi::Function::New(env, Wrap_Installation_get_config));
  installation_class.Set("getCurrentInstalledApp", Napi::Function::New(env, Wrap_Installation_get_current_installed_app));
  installation_class.Set("getDefaultLanguages", Napi::Function::New(env, Wrap_Installation_get_default_languages));
  installation_class.Set("getDefaultLocales", Napi::Function::New(env, Wrap_Installation_get_default_locales));
  installation_class.Set("getDisplayName", Napi::Function::New(env, Wrap_Installation_get_display_name));
  installation_class.Set("getId", Napi::Function::New(env, Wrap_Installation_get_id));
  installation_class.Set("getInstalledRef", Napi::Function::New(env, Wrap_Installation_get_installed_ref));
  installation_class.Set("getIsUser", Napi::Function::New(env, Wrap_Installation_get_is_user));
  installation_class.Set("getMinFreeSpaceBytes", Napi::Function::New(env, Wrap_Installation_get_min_free_space_bytes));
  installation_class.Set("getNoInteraction", Napi::Function::New(env, Wrap_Installation_get_no_interaction));
  installation_class.Set("getPath", Napi::Function::New(env, Wrap_Installation_get_path));
  installation_class.Set("getPriority", Napi::Function::New(env, Wrap_Installation_get_priority));
  installation_class.Set("getRemoteByName", Napi::Function::New(env, Wrap_Installation_get_remote_by_name));
  installation_class.Set("getStorageType", Napi::Function::New(env, Wrap_Installation_get_storage_type));
  installation_class.Set("installRefFile", Napi::Function::New(env, Wrap_Installation_install_ref_file));
  installation_class.Set("launch", Napi::Function::New(env, Wrap_Installation_launch));
  installation_class.Set("launchFull", Napi::Function::New(env, Wrap_Installation_launch_full));
  installation_class.Set("listInstalledRefs", Napi::Function::New(env, Wrap_Installation_list_installed_refs));
  installation_class.Set("listInstalledRefsByKind", Napi::Function::New(env, Wrap_Installation_list_installed_refs_by_kind));
  installation_class.Set("listInstalledRefsForUpdate", Napi::Function::New(env, Wrap_Installation_list_installed_refs_for_update));
  installation_class.Set("listInstalledRelatedRefsSync", Napi::Function::New(env, Wrap_Installation_list_installed_related_refs_sync));
  installation_class.Set("listPinnedRefs", Napi::Function::New(env, Wrap_Installation_list_pinned_refs));
  installation_class.Set("listRemoteRefsSync", Napi::Function::New(env, Wrap_Installation_list_remote_refs_sync));
  installation_class.Set("listRemoteRefsSyncFull", Napi::Function::New(env, Wrap_Installation_list_remote_refs_sync_full));
  installation_class.Set("listRemoteRelatedRefsForInstalledSync", Napi::Function::New(env, Wrap_Installation_list_remote_related_refs_for_installed_sync));
  installation_class.Set("listRemoteRelatedRefsSync", Napi::Function::New(env, Wrap_Installation_list_remote_related_refs_sync));
  installation_class.Set("listRemotes", Napi::Function::New(env, Wrap_Installation_list_remotes));
  installation_class.Set("listUnusedRefs", Napi::Function::New(env, Wrap_Installation_list_unused_refs));
  installation_class.Set("listUnusedRefsWithOptions", Napi::Function::New(env, Wrap_Installation_list_unused_refs_with_options));
  installation_class.Set("loadAppOverrides", Napi::Function::New(env, Wrap_Installation_load_app_overrides));
  installation_class.Set("modifyRemote", Napi::Function::New(env, Wrap_Installation_modify_remote));
  installation_class.Set("pruneLocalRepo", Napi::Function::New(env, Wrap_Installation_prune_local_repo));
  installation_class.Set("removeLocalRefSync", Napi::Function::New(env, Wrap_Installation_remove_local_ref_sync));
  installation_class.Set("removeRemote", Napi::Function::New(env, Wrap_Installation_remove_remote));
  installation_class.Set("runTriggers", Napi::Function::New(env, Wrap_Installation_run_triggers));
  installation_class.Set("setConfigSync", Napi::Function::New(env, Wrap_Installation_set_config_sync));
  installation_class.Set("setNoInteraction", Napi::Function::New(env, Wrap_Installation_set_no_interaction));
  installation_class.Set("updateAppstreamSync", Napi::Function::New(env, Wrap_Installation_update_appstream_sync));
  installation_class.Set("updateRemoteSync", Napi::Function::New(env, Wrap_Installation_update_remote_sync));
  exports.Set("Installation", installation_class);
  // InstalledRef class
  Napi::Object installedref_class = Napi::Object::New(env);
  installedref_class.Set("getAppdataContentRating", Napi::Function::New(env, Wrap_InstalledRef_get_appdata_content_rating));
  installedref_class.Set("getAppdataContentRatingType", Napi::Function::New(env, Wrap_InstalledRef_get_appdata_content_rating_type));
  installedref_class.Set("getAppdataLicense", Napi::Function::New(env, Wrap_InstalledRef_get_appdata_license));
  installedref_class.Set("getAppdataName", Napi::Function::New(env, Wrap_InstalledRef_get_appdata_name));
  installedref_class.Set("getAppdataSummary", Napi::Function::New(env, Wrap_InstalledRef_get_appdata_summary));
  installedref_class.Set("getAppdataVersion", Napi::Function::New(env, Wrap_InstalledRef_get_appdata_version));
  installedref_class.Set("getDeployDir", Napi::Function::New(env, Wrap_InstalledRef_get_deploy_dir));
  installedref_class.Set("getEol", Napi::Function::New(env, Wrap_InstalledRef_get_eol));
  installedref_class.Set("getEolRebase", Napi::Function::New(env, Wrap_InstalledRef_get_eol_rebase));
  installedref_class.Set("getInstalledSize", Napi::Function::New(env, Wrap_InstalledRef_get_installed_size));
  installedref_class.Set("getIsCurrent", Napi::Function::New(env, Wrap_InstalledRef_get_is_current));
  installedref_class.Set("getLatestCommit", Napi::Function::New(env, Wrap_InstalledRef_get_latest_commit));
  installedref_class.Set("getOrigin", Napi::Function::New(env, Wrap_InstalledRef_get_origin));
  installedref_class.Set("getSubpaths", Napi::Function::New(env, Wrap_InstalledRef_get_subpaths));
  installedref_class.Set("loadAppdata", Napi::Function::New(env, Wrap_InstalledRef_load_appdata));
  installedref_class.Set("loadMetadata", Napi::Function::New(env, Wrap_InstalledRef_load_metadata));
  exports.Set("InstalledRef", installedref_class);
  // Instance class
  Napi::Object instance_class = Napi::Object::New(env);
  instance_class.Set("getApp", Napi::Function::New(env, Wrap_Instance_get_app));
  instance_class.Set("getArch", Napi::Function::New(env, Wrap_Instance_get_arch));
  instance_class.Set("getBranch", Napi::Function::New(env, Wrap_Instance_get_branch));
  instance_class.Set("getChildPid", Napi::Function::New(env, Wrap_Instance_get_child_pid));
  instance_class.Set("getCommit", Napi::Function::New(env, Wrap_Instance_get_commit));
  instance_class.Set("getId", Napi::Function::New(env, Wrap_Instance_get_id));
  instance_class.Set("getInfo", Napi::Function::New(env, Wrap_Instance_get_info));
  instance_class.Set("getPid", Napi::Function::New(env, Wrap_Instance_get_pid));
  instance_class.Set("getRuntime", Napi::Function::New(env, Wrap_Instance_get_runtime));
  instance_class.Set("getRuntimeCommit", Napi::Function::New(env, Wrap_Instance_get_runtime_commit));
  instance_class.Set("isRunning", Napi::Function::New(env, Wrap_Instance_is_running));
  exports.Set("Instance", instance_class);
  // Ref class
  Napi::Object ref_class = Napi::Object::New(env);
  ref_class.Set("formatRef", Napi::Function::New(env, Wrap_Ref_format_ref));
  ref_class.Set("formatRefCached", Napi::Function::New(env, Wrap_Ref_format_ref_cached));
  ref_class.Set("getArch", Napi::Function::New(env, Wrap_Ref_get_arch));
  ref_class.Set("getBranch", Napi::Function::New(env, Wrap_Ref_get_branch));
  ref_class.Set("getCollectionId", Napi::Function::New(env, Wrap_Ref_get_collection_id));
  ref_class.Set("getCommit", Napi::Function::New(env, Wrap_Ref_get_commit));
  ref_class.Set("getKind", Napi::Function::New(env, Wrap_Ref_get_kind));
  ref_class.Set("getName", Napi::Function::New(env, Wrap_Ref_get_name));
  exports.Set("Ref", ref_class);
  // RelatedRef class
  Napi::Object relatedref_class = Napi::Object::New(env);
  relatedref_class.Set("getSubpaths", Napi::Function::New(env, Wrap_RelatedRef_get_subpaths));
  relatedref_class.Set("shouldAutoprune", Napi::Function::New(env, Wrap_RelatedRef_should_autoprune));
  relatedref_class.Set("shouldDelete", Napi::Function::New(env, Wrap_RelatedRef_should_delete));
  relatedref_class.Set("shouldDownload", Napi::Function::New(env, Wrap_RelatedRef_should_download));
  exports.Set("RelatedRef", relatedref_class);
  // Remote class
  Napi::Object remote_class = Napi::Object::New(env);
  remote_class.Set("new", Napi::Function::New(env, Wrap_Remote_new));
  remote_class.Set("new", Napi::Function::New(env, Wrap_Remote_new_from_file));
  remote_class.Set("getAppstreamDir", Napi::Function::New(env, Wrap_Remote_get_appstream_dir));
  remote_class.Set("getAppstreamTimestamp", Napi::Function::New(env, Wrap_Remote_get_appstream_timestamp));
  remote_class.Set("getCollectionId", Napi::Function::New(env, Wrap_Remote_get_collection_id));
  remote_class.Set("getComment", Napi::Function::New(env, Wrap_Remote_get_comment));
  remote_class.Set("getDefaultBranch", Napi::Function::New(env, Wrap_Remote_get_default_branch));
  remote_class.Set("getDescription", Napi::Function::New(env, Wrap_Remote_get_description));
  remote_class.Set("getDisabled", Napi::Function::New(env, Wrap_Remote_get_disabled));
  remote_class.Set("getFilter", Napi::Function::New(env, Wrap_Remote_get_filter));
  remote_class.Set("getGpgVerify", Napi::Function::New(env, Wrap_Remote_get_gpg_verify));
  remote_class.Set("getHomepage", Napi::Function::New(env, Wrap_Remote_get_homepage));
  remote_class.Set("getIcon", Napi::Function::New(env, Wrap_Remote_get_icon));
  remote_class.Set("getMainRef", Napi::Function::New(env, Wrap_Remote_get_main_ref));
  remote_class.Set("getName", Napi::Function::New(env, Wrap_Remote_get_name));
  remote_class.Set("getNodeps", Napi::Function::New(env, Wrap_Remote_get_nodeps));
  remote_class.Set("getNoenumerate", Napi::Function::New(env, Wrap_Remote_get_noenumerate));
  remote_class.Set("getPrio", Napi::Function::New(env, Wrap_Remote_get_prio));
  remote_class.Set("getRemoteType", Napi::Function::New(env, Wrap_Remote_get_remote_type));
  remote_class.Set("getTitle", Napi::Function::New(env, Wrap_Remote_get_title));
  remote_class.Set("getUrl", Napi::Function::New(env, Wrap_Remote_get_url));
  remote_class.Set("setCollectionId", Napi::Function::New(env, Wrap_Remote_set_collection_id));
  remote_class.Set("setComment", Napi::Function::New(env, Wrap_Remote_set_comment));
  remote_class.Set("setDefaultBranch", Napi::Function::New(env, Wrap_Remote_set_default_branch));
  remote_class.Set("setDescription", Napi::Function::New(env, Wrap_Remote_set_description));
  remote_class.Set("setDisabled", Napi::Function::New(env, Wrap_Remote_set_disabled));
  remote_class.Set("setFilter", Napi::Function::New(env, Wrap_Remote_set_filter));
  remote_class.Set("setGpgKey", Napi::Function::New(env, Wrap_Remote_set_gpg_key));
  remote_class.Set("setGpgVerify", Napi::Function::New(env, Wrap_Remote_set_gpg_verify));
  remote_class.Set("setHomepage", Napi::Function::New(env, Wrap_Remote_set_homepage));
  remote_class.Set("setIcon", Napi::Function::New(env, Wrap_Remote_set_icon));
  remote_class.Set("setMainRef", Napi::Function::New(env, Wrap_Remote_set_main_ref));
  remote_class.Set("setNodeps", Napi::Function::New(env, Wrap_Remote_set_nodeps));
  remote_class.Set("setNoenumerate", Napi::Function::New(env, Wrap_Remote_set_noenumerate));
  remote_class.Set("setPrio", Napi::Function::New(env, Wrap_Remote_set_prio));
  remote_class.Set("setTitle", Napi::Function::New(env, Wrap_Remote_set_title));
  remote_class.Set("setUrl", Napi::Function::New(env, Wrap_Remote_set_url));
  exports.Set("Remote", remote_class);
  // RemoteRef class
  Napi::Object remoteref_class = Napi::Object::New(env);
  remoteref_class.Set("getDownloadSize", Napi::Function::New(env, Wrap_RemoteRef_get_download_size));
  remoteref_class.Set("getEol", Napi::Function::New(env, Wrap_RemoteRef_get_eol));
  remoteref_class.Set("getEolRebase", Napi::Function::New(env, Wrap_RemoteRef_get_eol_rebase));
  remoteref_class.Set("getInstalledSize", Napi::Function::New(env, Wrap_RemoteRef_get_installed_size));
  remoteref_class.Set("getMetadata", Napi::Function::New(env, Wrap_RemoteRef_get_metadata));
  remoteref_class.Set("getRemoteName", Napi::Function::New(env, Wrap_RemoteRef_get_remote_name));
  exports.Set("RemoteRef", remoteref_class);
  // Transaction class
  Napi::Object transaction_class = Napi::Object::New(env);
  transaction_class.Set("new", Napi::Function::New(env, Wrap_Transaction_new_for_installation));
  transaction_class.Set("abortWebflow", Napi::Function::New(env, Wrap_Transaction_abort_webflow));
  transaction_class.Set("addDefaultDependencySources", Napi::Function::New(env, Wrap_Transaction_add_default_dependency_sources));
  transaction_class.Set("addDependencySource", Napi::Function::New(env, Wrap_Transaction_add_dependency_source));
  transaction_class.Set("addInstallBundle", Napi::Function::New(env, Wrap_Transaction_add_install_bundle));
  transaction_class.Set("addInstallFlatpakref", Napi::Function::New(env, Wrap_Transaction_add_install_flatpakref));
  transaction_class.Set("addSideloadRepo", Napi::Function::New(env, Wrap_Transaction_add_sideload_repo));
  transaction_class.Set("addUninstall", Napi::Function::New(env, Wrap_Transaction_add_uninstall));
  transaction_class.Set("completeBasicAuth", Napi::Function::New(env, Wrap_Transaction_complete_basic_auth));
  transaction_class.Set("getAutoInstallDebug", Napi::Function::New(env, Wrap_Transaction_get_auto_install_debug));
  transaction_class.Set("getAutoInstallSdk", Napi::Function::New(env, Wrap_Transaction_get_auto_install_sdk));
  transaction_class.Set("getCurrentOperation", Napi::Function::New(env, Wrap_Transaction_get_current_operation));
  transaction_class.Set("getIncludeUnusedUninstallOps", Napi::Function::New(env, Wrap_Transaction_get_include_unused_uninstall_ops));
  transaction_class.Set("getInstallation", Napi::Function::New(env, Wrap_Transaction_get_installation));
  transaction_class.Set("getNoDeploy", Napi::Function::New(env, Wrap_Transaction_get_no_deploy));
  transaction_class.Set("getNoInteraction", Napi::Function::New(env, Wrap_Transaction_get_no_interaction));
  transaction_class.Set("getNoPull", Napi::Function::New(env, Wrap_Transaction_get_no_pull));
  transaction_class.Set("getOperationForRef", Napi::Function::New(env, Wrap_Transaction_get_operation_for_ref));
  transaction_class.Set("getOperations", Napi::Function::New(env, Wrap_Transaction_get_operations));
  transaction_class.Set("getParentWindow", Napi::Function::New(env, Wrap_Transaction_get_parent_window));
  transaction_class.Set("isEmpty", Napi::Function::New(env, Wrap_Transaction_is_empty));
  transaction_class.Set("run", Napi::Function::New(env, Wrap_Transaction_run));
  transaction_class.Set("setAutoInstallDebug", Napi::Function::New(env, Wrap_Transaction_set_auto_install_debug));
  transaction_class.Set("setAutoInstallSdk", Napi::Function::New(env, Wrap_Transaction_set_auto_install_sdk));
  transaction_class.Set("setDefaultArch", Napi::Function::New(env, Wrap_Transaction_set_default_arch));
  transaction_class.Set("setDisableAutoPin", Napi::Function::New(env, Wrap_Transaction_set_disable_auto_pin));
  transaction_class.Set("setDisableDependencies", Napi::Function::New(env, Wrap_Transaction_set_disable_dependencies));
  transaction_class.Set("setDisablePrune", Napi::Function::New(env, Wrap_Transaction_set_disable_prune));
  transaction_class.Set("setDisableRelated", Napi::Function::New(env, Wrap_Transaction_set_disable_related));
  transaction_class.Set("setDisableStaticDeltas", Napi::Function::New(env, Wrap_Transaction_set_disable_static_deltas));
  transaction_class.Set("setForceUninstall", Napi::Function::New(env, Wrap_Transaction_set_force_uninstall));
  transaction_class.Set("setIncludeUnusedUninstallOps", Napi::Function::New(env, Wrap_Transaction_set_include_unused_uninstall_ops));
  transaction_class.Set("setNoDeploy", Napi::Function::New(env, Wrap_Transaction_set_no_deploy));
  transaction_class.Set("setNoInteraction", Napi::Function::New(env, Wrap_Transaction_set_no_interaction));
  transaction_class.Set("setNoPull", Napi::Function::New(env, Wrap_Transaction_set_no_pull));
  transaction_class.Set("setParentWindow", Napi::Function::New(env, Wrap_Transaction_set_parent_window));
  transaction_class.Set("setReinstall", Napi::Function::New(env, Wrap_Transaction_set_reinstall));
  exports.Set("Transaction", transaction_class);
  // TransactionOperation class
  Napi::Object transactionoperation_class = Napi::Object::New(env);
  transactionoperation_class.Set("getBundlePath", Napi::Function::New(env, Wrap_TransactionOperation_get_bundle_path));
  transactionoperation_class.Set("getCommit", Napi::Function::New(env, Wrap_TransactionOperation_get_commit));
  transactionoperation_class.Set("getDownloadSize", Napi::Function::New(env, Wrap_TransactionOperation_get_download_size));
  transactionoperation_class.Set("getInstalledSize", Napi::Function::New(env, Wrap_TransactionOperation_get_installed_size));
  transactionoperation_class.Set("getIsSkipped", Napi::Function::New(env, Wrap_TransactionOperation_get_is_skipped));
  transactionoperation_class.Set("getMetadata", Napi::Function::New(env, Wrap_TransactionOperation_get_metadata));
  transactionoperation_class.Set("getOldMetadata", Napi::Function::New(env, Wrap_TransactionOperation_get_old_metadata));
  transactionoperation_class.Set("getOperationType", Napi::Function::New(env, Wrap_TransactionOperation_get_operation_type));
  transactionoperation_class.Set("getRef", Napi::Function::New(env, Wrap_TransactionOperation_get_ref));
  transactionoperation_class.Set("getRelatedToOps", Napi::Function::New(env, Wrap_TransactionOperation_get_related_to_ops));
  transactionoperation_class.Set("getRemote", Napi::Function::New(env, Wrap_TransactionOperation_get_remote));
  transactionoperation_class.Set("getRequiresAuthentication", Napi::Function::New(env, Wrap_TransactionOperation_get_requires_authentication));
  transactionoperation_class.Set("getSubpaths", Napi::Function::New(env, Wrap_TransactionOperation_get_subpaths));
  exports.Set("TransactionOperation", transactionoperation_class);
  // TransactionProgress class
  Napi::Object transactionprogress_class = Napi::Object::New(env);
  transactionprogress_class.Set("getBytesTransferred", Napi::Function::New(env, Wrap_TransactionProgress_get_bytes_transferred));
  transactionprogress_class.Set("getIsEstimating", Napi::Function::New(env, Wrap_TransactionProgress_get_is_estimating));
  transactionprogress_class.Set("getProgress", Napi::Function::New(env, Wrap_TransactionProgress_get_progress));
  transactionprogress_class.Set("getStartTime", Napi::Function::New(env, Wrap_TransactionProgress_get_start_time));
  transactionprogress_class.Set("getStatus", Napi::Function::New(env, Wrap_TransactionProgress_get_status));
  transactionprogress_class.Set("setUpdateFrequency", Napi::Function::New(env, Wrap_TransactionProgress_set_update_frequency));
  exports.Set("TransactionProgress", transactionprogress_class);
  return exports;
}

NODE_API_MODULE(NODE_GYP_MODULE_NAME, Init)